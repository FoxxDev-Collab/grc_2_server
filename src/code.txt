This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
app.controller.spec.ts
app.controller.ts
app.module.ts
app.service.ts
auth/auth.controller.ts
auth/auth.module.ts
auth/auth.service.ts
auth/dto/login.dto.ts
auth/guards/jwt-auth.guard.ts
auth/guards/roles.guard.ts
auth/strategies/jwt.strategy.ts
clients/clients.controller.ts
clients/clients.module.ts
clients/clients.service.ts
clients/dto/create-client-user.dto.ts
clients/dto/create-client.dto.ts
clients/dto/update-client-user.dto.ts
clients/dto/update-client.dto.ts
clients/entities/client-user.entity.ts
clients/entities/client.entity.ts
common/common.module.ts
common/decorators/roles.decorator.ts
common/dto/pagination.dto.ts
common/filters/http-exception.filter.ts
common/interfaces/api-response.interface.ts
common/services/utility.service.ts
config/app.config.ts
config/database.config.ts
main.ts
migrations/1709575571000-InitialSchema.ts
migrations/1709575572000-SeedData.ts
scripts/create-database.ts
users/dto/create-user.dto.ts
users/dto/update-user.dto.ts
users/entities/user.entity.ts
users/users.controller.ts
users/users.module.ts
users/users.service.ts

================================================================
Files
================================================================

================
File: app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: app.module.ts
================
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule, TypeOrmModuleOptions } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import databaseConfig from './config/database.config';
import appConfig from './config/app.config';
import { CommonModule } from './common/common.module';
import { UsersModule } from './users/users.module';
import { AuthModule } from './auth/auth.module';
import { ClientsModule } from './clients/clients.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [databaseConfig, appConfig],
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService): TypeOrmModuleOptions => {
        const dbConfig = configService.get<TypeOrmModuleOptions>('database');
        if (!dbConfig) {
          throw new Error('Database configuration not found');
        }
        
        // Set synchronize to true to create tables automatically
        return {
          ...dbConfig,
          synchronize: true,
          autoLoadEntities: true,
        };
      },
    }),
    CommonModule,
    UsersModule,
    AuthModule,
    ClientsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

================
File: app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: auth/auth.controller.ts
================
import {
  Controller,
  Post,
  Body,
  UseGuards,
  Get,
  Request,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { ApiResponse } from '../common/interfaces/api-response.interface';
import { UtilityService } from '../common/services/utility.service';

interface RequestWithUser {
  user: {
    id: number;
    email: string;
    role: string;
  };
}

@Controller('auth')
export class AuthController {
  constructor(
    private readonly authService: AuthService,
    private readonly utilityService: UtilityService,
  ) {}

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() loginDto: LoginDto): Promise<ApiResponse<any>> {
    const result = await this.authService.login(loginDto);
    return this.utilityService.createSuccessResponse(
      result,
      'Login successful',
    );
  }

  @UseGuards(JwtAuthGuard)
  @Get('me')
  getProfile(@Request() req: RequestWithUser): ApiResponse<any> {
    return this.utilityService.createSuccessResponse(
      req.user,
      'User profile retrieved successfully',
    );
  }

  @UseGuards(JwtAuthGuard)
  @Post('refresh-token')
  async refreshToken(@Request() req: RequestWithUser): Promise<ApiResponse<any>> {
    const result = await this.authService.refreshToken(req.user.id);
    return this.utilityService.createSuccessResponse(
      result,
      'Token refreshed successfully',
    );
  }
}

================
File: auth/auth.module.ts
================
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './strategies/jwt.strategy';
import { RolesGuard } from './guards/roles.guard';
import { CommonModule } from '../common/common.module';

@Module({
  imports: [
    UsersModule,
    CommonModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('app.jwtSecret'),
        signOptions: { 
          expiresIn: configService.get<string>('app.jwtExpiresIn') || '1d',
        },
      }),
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, RolesGuard],
  exports: [AuthService, RolesGuard],
})
export class AuthModule {}

================
File: auth/auth.service.ts
================
import { Injectable, UnauthorizedException, Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { UsersService } from '../users/users.service';
import { LoginDto } from './dto/login.dto';
import { User } from '../users/entities/user.entity';

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async validateUser(email: string, password: string): Promise<Omit<User, 'password'> | null> {
    try {
      const user = await this.usersService.findByEmail(email);
      
      if (!user) {
        return null;
      }
      
      const isPasswordValid = await bcrypt.compare(password, user.password);
      
      if (!isPasswordValid) {
        return null;
      }
      
      // Update last login time
      await this.usersService.update(user.id, { 
        lastLogin: new Date(),
        failedLoginAttempts: 0,
      });
      
      const { password: _, ...result } = user;
      return result;
    } catch (error) {
      this.logger.error(`Error validating user: ${(error as Error).message}`, (error as Error).stack);
      return null;
    }
  }

  async login(loginDto: LoginDto) {
    const user = await this.validateUser(loginDto.email, loginDto.password);
    
    if (!user) {
      // Increment failed login attempts
      const existingUser = await this.usersService.findByEmail(loginDto.email);
      if (existingUser) {
        await this.usersService.update(existingUser.id, {
          failedLoginAttempts: existingUser.failedLoginAttempts + 1,
        });
      }
      throw new UnauthorizedException('Invalid credentials');
    }
    
    const payload = { 
      email: user.email, 
      sub: user.id,
      role: user.role,
    };
    
    return {
      accessToken: this.jwtService.sign(payload),
      user,
    };
  }

  async refreshToken(userId: number) {
    const user = await this.usersService.findOne(userId);
    
    const payload = { 
      email: user.email, 
      sub: user.id,
      role: user.role,
    };
    
    return {
      accessToken: this.jwtService.sign(payload),
    };
  }
}

================
File: auth/dto/login.dto.ts
================
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @IsString()
  password: string;
}

================
File: auth/guards/jwt-auth.guard.ts
================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

================
File: auth/guards/roles.guard.ts
================
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../../common/decorators/roles.decorator';

interface RequestWithUser {
  user: {
    id: number;
    email: string;
    role: string;
  };
}

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    
    if (!requiredRoles) {
      return true;
    }
    
    const request = context.switchToHttp().getRequest<RequestWithUser>();
    return requiredRoles.includes(request.user.role);
  }
}

================
File: auth/strategies/jwt.strategy.ts
================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../../users/users.service';

interface JwtPayload {
  sub: number;
  email: string;
  role: string;
  iat?: number;
  exp?: number;
}

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private configService: ConfigService,
    private usersService: UsersService,
  ) {
    const jwtSecret = configService.get<string>('app.jwtSecret');
    if (!jwtSecret) {
      throw new Error('JWT secret is not defined');
    }
    
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: JwtPayload) {
    const user = await this.usersService.findOne(payload.sub);
    
    if (!user || !user.isActive) {
      throw new UnauthorizedException('User is not active or does not exist');
    }
    
    return {
      id: user.id,
      email: user.email,
      role: user.role,
    };
  }
}

================
File: clients/clients.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
} from '@nestjs/common';
import { ClientsService } from './clients.service';
import { CreateClientDto } from './dto/create-client.dto';
import { UpdateClientDto } from './dto/update-client.dto';
import { CreateClientUserDto } from './dto/create-client-user.dto';
import { UpdateClientUserDto } from './dto/update-client-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { ApiResponse } from '../common/interfaces/api-response.interface';
import { Client } from './entities/client.entity';
import { ClientUser } from './entities/client-user.entity';
import { UtilityService } from '../common/services/utility.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { Roles } from '../common/decorators/roles.decorator';
import { RolesGuard } from '../auth/guards/roles.guard';

@Controller('clients')
@UseGuards(JwtAuthGuard, RolesGuard)
export class ClientsController {
  constructor(
    private readonly clientsService: ClientsService,
    private readonly utilityService: UtilityService,
  ) {}

  @Post()
  @Roles('admin')
  async create(@Body() createClientDto: CreateClientDto): Promise<ApiResponse<Client>> {
    const client = await this.clientsService.create(createClientDto);
    return this.utilityService.createSuccessResponse(
      client,
      'Client created successfully',
    );
  }

  @Get()
  @Roles('admin')
  async findAll(@Query() paginationDto: PaginationDto): Promise<ApiResponse<{ clients: Client[]; total: number }>> {
    const [clients, total] = await this.clientsService.findAll(paginationDto);
    return this.utilityService.createSuccessResponse(
      { clients, total },
      'Clients retrieved successfully',
      {
        page: paginationDto.page,
        limit: paginationDto.limit,
        totalPages: Math.ceil(total / paginationDto.limit),
      },
    );
  }

  @Get(':id')
  @Roles('admin')
  async findOne(@Param('id') id: string): Promise<ApiResponse<Client>> {
    const client = await this.clientsService.findOne(+id);
    return this.utilityService.createSuccessResponse(
      client,
      'Client retrieved successfully',
    );
  }

  @Patch(':id')
  @Roles('admin')
  async update(
    @Param('id') id: string,
    @Body() updateClientDto: UpdateClientDto,
  ): Promise<ApiResponse<Client>> {
    const client = await this.clientsService.update(+id, updateClientDto);
    return this.utilityService.createSuccessResponse(
      client,
      'Client updated successfully',
    );
  }

  @Delete(':id')
  @Roles('admin')
  async remove(@Param('id') id: string): Promise<ApiResponse<null>> {
    await this.clientsService.remove(+id);
    return this.utilityService.createSuccessResponse(
      null,
      'Client deleted successfully',
    );
  }

  // Client User endpoints
  @Post(':clientId/users')
  @Roles('admin')
  async createClientUser(
    @Param('clientId') clientId: string,
    @Body() createClientUserDto: CreateClientUserDto,
  ): Promise<ApiResponse<ClientUser>> {
    // Ensure clientId in path matches the one in the DTO
    createClientUserDto.clientId = +clientId;
    
    const clientUser = await this.clientsService.createClientUser(createClientUserDto);
    return this.utilityService.createSuccessResponse(
      clientUser,
      'Client user created successfully',
    );
  }

  @Get(':clientId/users')
  @Roles('admin')
  async findClientUsers(
    @Param('clientId') clientId: string,
    @Query() paginationDto: PaginationDto,
  ): Promise<ApiResponse<{ users: ClientUser[]; total: number }>> {
    const [users, total] = await this.clientsService.findClientUsers(+clientId, paginationDto);
    return this.utilityService.createSuccessResponse(
      { users, total },
      'Client users retrieved successfully',
      {
        page: paginationDto.page,
        limit: paginationDto.limit,
        totalPages: Math.ceil(total / paginationDto.limit),
      },
    );
  }

  @Get(':clientId/users/:userId')
  @Roles('admin')
  async findClientUser(
    @Param('clientId') clientId: string,
    @Param('userId') userId: string,
  ): Promise<ApiResponse<ClientUser>> {
    const clientUser = await this.clientsService.findClientUser(+clientId, +userId);
    return this.utilityService.createSuccessResponse(
      clientUser,
      'Client user retrieved successfully',
    );
  }

  @Patch(':clientId/users/:userId')
  @Roles('admin')
  async updateClientUser(
    @Param('clientId') clientId: string,
    @Param('userId') userId: string,
    @Body() updateClientUserDto: UpdateClientUserDto,
  ): Promise<ApiResponse<ClientUser>> {
    const clientUser = await this.clientsService.updateClientUser(+clientId, +userId, updateClientUserDto);
    return this.utilityService.createSuccessResponse(
      clientUser,
      'Client user updated successfully',
    );
  }

  @Delete(':clientId/users/:userId')
  @Roles('admin')
  async removeClientUser(
    @Param('clientId') clientId: string,
    @Param('userId') userId: string,
  ): Promise<ApiResponse<null>> {
    await this.clientsService.removeClientUser(+clientId, +userId);
    return this.utilityService.createSuccessResponse(
      null,
      'Client user deleted successfully',
    );
  }
}

================
File: clients/clients.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ClientsService } from './clients.service';
import { ClientsController } from './clients.controller';
import { Client } from './entities/client.entity';
import { ClientUser } from './entities/client-user.entity';
import { CommonModule } from '../common/common.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([Client, ClientUser]),
    CommonModule,
  ],
  controllers: [ClientsController],
  providers: [ClientsService],
  exports: [ClientsService],
})
export class ClientsModule {}

================
File: clients/clients.service.ts
================
import {
  Injectable,
  NotFoundException,
  ConflictException,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Client } from './entities/client.entity';
import { ClientUser } from './entities/client-user.entity';
import { CreateClientDto } from './dto/create-client.dto';
import { UpdateClientDto } from './dto/update-client.dto';
import { CreateClientUserDto } from './dto/create-client-user.dto';
import { UpdateClientUserDto } from './dto/update-client-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class ClientsService {
  private readonly logger = new Logger(ClientsService.name);

  constructor(
    @InjectRepository(Client)
    private clientsRepository: Repository<Client>,
    @InjectRepository(ClientUser)
    private clientUsersRepository: Repository<ClientUser>,
  ) {}

  async create(createClientDto: CreateClientDto): Promise<Client> {
    try {
      const client = this.clientsRepository.create(createClientDto);
      return await this.clientsRepository.save(client);
    } catch (error) {
      this.logger.error(`Failed to create client: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to create client');
    }
  }

  async findAll(paginationDto: PaginationDto): Promise<[Client[], number]> {
    try {
      return await this.clientsRepository.findAndCount({
        skip: paginationDto.skip,
        take: paginationDto.limit,
        order: {
          createdAt: 'DESC',
        },
      });
    } catch (error) {
      this.logger.error(`Failed to find clients: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to find clients');
    }
  }

  async findOne(id: number): Promise<Client> {
    try {
      const client = await this.clientsRepository.findOne({ 
        where: { id },
        relations: ['users'],
      });
      
      if (!client) {
        throw new NotFoundException(`Client with ID ${id} not found`);
      }
      
      return client;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to find client: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to find client');
    }
  }

  async update(id: number, updateClientDto: UpdateClientDto): Promise<Client> {
    try {
      const client = await this.findOne(id);
      
      Object.assign(client, updateClientDto);
      return await this.clientsRepository.save(client);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to update client: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to update client');
    }
  }

  async remove(id: number): Promise<void> {
    try {
      const result = await this.clientsRepository.delete(id);
      
      if (result.affected === 0) {
        throw new NotFoundException(`Client with ID ${id} not found`);
      }
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to remove client: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to remove client');
    }
  }

  // Client User methods
  async createClientUser(createClientUserDto: CreateClientUserDto): Promise<ClientUser> {
    try {
      // Check if client exists
      await this.findOne(createClientUserDto.clientId);
      
      // Check if user with email already exists for this client
      const existingUser = await this.clientUsersRepository.findOne({
        where: {
          clientId: createClientUserDto.clientId,
          email: createClientUserDto.email,
        },
      });
      
      if (existingUser) {
        throw new ConflictException('User with this email already exists for this client');
      }
      
      const clientUser = this.clientUsersRepository.create(createClientUserDto);
      return await this.clientUsersRepository.save(clientUser);
    } catch (error) {
      if (error instanceof NotFoundException || error instanceof ConflictException) {
        throw error;
      }
      this.logger.error(`Failed to create client user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to create client user');
    }
  }

  async findClientUsers(clientId: number, paginationDto: PaginationDto): Promise<[ClientUser[], number]> {
    try {
      // Check if client exists
      await this.findOne(clientId);
      
      return await this.clientUsersRepository.findAndCount({
        where: { clientId },
        skip: paginationDto.skip,
        take: paginationDto.limit,
        order: {
          createdAt: 'DESC',
        },
      });
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to find client users: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to find client users');
    }
  }

  async findClientUser(clientId: number, userId: number): Promise<ClientUser> {
    try {
      const clientUser = await this.clientUsersRepository.findOne({
        where: {
          id: userId,
          clientId,
        },
      });
      
      if (!clientUser) {
        throw new NotFoundException(`User with ID ${userId} not found for client ${clientId}`);
      }
      
      return clientUser;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to find client user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to find client user');
    }
  }

  async updateClientUser(clientId: number, userId: number, updateClientUserDto: UpdateClientUserDto): Promise<ClientUser> {
    try {
      const clientUser = await this.findClientUser(clientId, userId);
      
      Object.assign(clientUser, updateClientUserDto);
      return await this.clientUsersRepository.save(clientUser);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to update client user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to update client user');
    }
  }

  async removeClientUser(clientId: number, userId: number): Promise<void> {
    try {
      const result = await this.clientUsersRepository.delete({
        id: userId,
        clientId,
      });
      
      if (result.affected === 0) {
        throw new NotFoundException(`User with ID ${userId} not found for client ${clientId}`);
      }
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to remove client user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to remove client user');
    }
  }
}

================
File: clients/dto/create-client-user.dto.ts
================
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsNumber,
  IsArray,
  IsBoolean,
} from 'class-validator';

export class CreateClientUserDto {
  @IsNotEmpty()
  @IsString()
  username: string;

  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @IsString()
  role: string;

  @IsNotEmpty()
  @IsNumber()
  clientId: number;

  @IsNotEmpty()
  @IsString()
  firstName: string;

  @IsNotEmpty()
  @IsString()
  lastName: string;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  department?: string;

  @IsOptional()
  @IsString()
  phone?: string;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  permissions?: string[];
}

================
File: clients/dto/create-client.dto.ts
================
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  IsNumber,
  IsUrl,
  ValidateNested,
  IsObject,
} from 'class-validator';
import { Type } from 'class-transformer';
import { Address } from '../entities/client.entity';

export class AddressDto implements Address {
  @IsOptional()
  @IsString()
  street?: string;

  @IsOptional()
  @IsString()
  city?: string;

  @IsOptional()
  @IsString()
  state?: string;

  @IsOptional()
  @IsString()
  zipCode?: string;

  @IsOptional()
  @IsString()
  country?: string;

  [key: string]: unknown;
}

export class CreateClientDto {
  @IsNotEmpty()
  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  industry?: string;

  @IsOptional()
  @IsEmail()
  email?: string;

  @IsOptional()
  @IsString()
  phone?: string;

  @IsOptional()
  @IsString()
  primaryContact?: string;

  @IsOptional()
  @IsObject()
  @ValidateNested()
  @Type(() => AddressDto)
  address?: AddressDto;

  @IsOptional()
  @IsString()
  size?: string;

  @IsOptional()
  @IsNumber()
  employeeCount?: number;

  @IsOptional()
  @IsUrl()
  website?: string;
}

================
File: clients/dto/update-client-user.dto.ts
================
import {
  IsEmail,
  IsOptional,
  IsString,
  IsNumber,
  IsArray,
  IsBoolean,
} from 'class-validator';
import { PartialType } from '@nestjs/mapped-types';
import { CreateClientUserDto } from './create-client-user.dto';

export class UpdateClientUserDto extends PartialType(CreateClientUserDto) {
  @IsOptional()
  @IsEmail()
  email?: string;

  @IsOptional()
  @IsString()
  role?: string;

  @IsOptional()
  @IsNumber()
  clientId?: number;

  @IsOptional()
  @IsString()
  firstName?: string;

  @IsOptional()
  @IsString()
  lastName?: string;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  department?: string;

  @IsOptional()
  @IsString()
  phone?: string;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  permissions?: string[];
}

================
File: clients/dto/update-client.dto.ts
================
import {
  IsOptional,
  IsString,
  IsNumber,
  IsDate,
} from 'class-validator';
import { Type } from 'class-transformer';
import { PartialType } from '@nestjs/mapped-types';
import { CreateClientDto } from './create-client.dto';

export class UpdateClientDto extends PartialType(CreateClientDto) {
  @IsOptional()
  @Type(() => Date)
  @IsDate()
  lastActivity?: Date;

  @IsOptional()
  @IsNumber()
  complianceScore?: number;

  @IsOptional()
  @IsString()
  status?: string;
}

================
File: clients/entities/client-user.entity.ts
================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  JoinColumn,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';
import { Client } from './client.entity';

@Entity('client_users')
export class ClientUser {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  username: string;

  @Column()
  email: string;

  @Column()
  role: string;

  @Column()
  clientId: number;

  @ManyToOne(() => Client, (client: Client) => client.users)
  @JoinColumn({ name: 'clientId' })
  client: Client;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ nullable: true })
  title: string;

  @Column({ nullable: true })
  department: string;

  @Column({ nullable: true })
  phone: string;

  @Column({ default: true })
  isActive: boolean;

  @Column({ nullable: true, type: 'timestamp' })
  lastActive: Date;

  @Column({ type: 'json', nullable: true })
  permissions: string[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

================
File: clients/entities/client.entity.ts
================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  OneToMany,
} from 'typeorm';
import { ClientUser } from './client-user.entity';

export interface Address {
  street?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
  [key: string]: unknown;
}

@Entity('clients')
export class Client {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @Column({ nullable: true })
  industry: string;

  @Column({ nullable: true })
  email: string;

  @Column({ nullable: true })
  phone: string;

  @Column({ nullable: true })
  primaryContact: string;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ nullable: true, type: 'timestamp' })
  lastActivity: Date;

  @Column({ nullable: true })
  complianceScore: number;

  @Column({ default: 'active' })
  status: string;

  @Column({ type: 'json', nullable: true })
  address: Address;

  @Column({ nullable: true })
  size: string;

  @Column({ nullable: true })
  employeeCount: number;

  @Column({ nullable: true })
  website: string;

  @OneToMany(() => ClientUser, (clientUser: ClientUser) => clientUser.client)
  users: ClientUser[];
}

================
File: common/common.module.ts
================
import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';
import { HttpExceptionFilter } from './filters/http-exception.filter';
import { UtilityService } from './services/utility.service';

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
    UtilityService,
  ],
  exports: [UtilityService],
})
export class CommonModule {}

================
File: common/decorators/roles.decorator.ts
================
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);

================
File: common/dto/pagination.dto.ts
================
import { IsNumber, IsOptional, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  page: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  @Min(1)
  limit: number = 10;

  get skip(): number {
    return (this.page - 1) * this.limit;
  }
}

================
File: common/filters/http-exception.filter.ts
================
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(HttpExceptionFilter.name);

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message: exception.message || null,
    };

    if (status === HttpStatus.INTERNAL_SERVER_ERROR as number) {
      this.logger.error(
        `${request.method} ${request.url}`,
        exception.stack,
        'HttpExceptionFilter',
      );
    } else {
      this.logger.error(
        `${request.method} ${request.url}`,
        JSON.stringify(errorResponse),
        'HttpExceptionFilter',
      );
    }

    response.status(status).json(errorResponse);
  }
}

================
File: common/interfaces/api-response.interface.ts
================
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: string[];
  meta?: {
    [key: string]: any;
  };
}

================
File: common/services/utility.service.ts
================
import { Injectable } from '@nestjs/common';
import { ApiResponse } from '../interfaces/api-response.interface';

@Injectable()
export class UtilityService {
  /**
   * Creates a standardized successful API response
   */
  createSuccessResponse<T, M extends { [key: string]: any; } | undefined = Record<string, unknown>>(data: T, message?: string, meta?: M): ApiResponse<T> {
    return {
      success: true,
      data,
      message,
      meta,
    };
  }

  /**
   * Creates a standardized error API response
   */
  createErrorResponse(message: string, errors?: string[]): ApiResponse<null> {
    return {
      success: false,
      message,
      errors,
    };
  }

  /**
   * Generates a random string of specified length
   */
  generateRandomString(length: number): string {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    const charactersLength = characters.length;
    
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    
    return result;
  }
}

================
File: config/app.config.ts
================
import { registerAs } from '@nestjs/config';

export default registerAs(
  'app',
  () => ({
    port: parseInt(process.env.PORT || '3000', 10),
    environment: process.env.NODE_ENV || 'development',
    apiPrefix: process.env.API_PREFIX || 'api',
    jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '1d',
  }),
);

================
File: config/database.config.ts
================
import { registerAs } from '@nestjs/config';
import { TypeOrmModuleOptions } from '@nestjs/typeorm';

export default registerAs(
  'database',
  (): TypeOrmModuleOptions => ({
    type: 'postgres',
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432', 10),
    username: process.env.DB_USERNAME || 'postgres',
    password: process.env.POSTGRES_PASSWORD || '',
    database: process.env.DB_DATABASE || 'grc_db',
    entities: ['dist/**/*.entity{.ts,.js}'],
    synchronize: process.env.NODE_ENV !== 'production',
    logging: process.env.NODE_ENV !== 'production',
    migrations: ['dist/migrations/**/*{.ts,.js}'],
    migrationsRun: true,
  }),
);

================
File: main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Logger } from '@nestjs/common';

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  const app = await NestFactory.create(AppModule);
  const configService = app.get(ConfigService);
  
  // Get configuration
  const port = configService.get<number>('app.port') || 3000;
  const environment = configService.get<string>('app.environment') || 'development';
  
  // Remove the global prefix to match frontend expectations
  // app.setGlobalPrefix(apiPrefix);
  
  // Enable CORS
  app.enableCors();
  
  // Set up global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );
  
  await app.listen(port);
  logger.log(`Application running in ${environment} mode on port ${port}`);
  logger.log(`API available at: http://localhost:${port}/`);
}

bootstrap();

================
File: migrations/1709575571000-InitialSchema.ts
================
import { MigrationInterface, QueryRunner } from 'typeorm';

export class InitialSchema1709575571000 implements MigrationInterface {
  name = 'InitialSchema1709575571000';

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Create users table
    await queryRunner.query(`
      CREATE TABLE "users" (
        "id" SERIAL NOT NULL,
        "email" character varying NOT NULL,
        "password" character varying NOT NULL,
        "firstName" character varying NOT NULL,
        "lastName" character varying NOT NULL,
        "role" character varying NOT NULL,
        "isActive" boolean NOT NULL DEFAULT true,
        "lastLogin" TIMESTAMP,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        "profileImage" character varying,
        "phoneNumber" character varying,
        "department" character varying,
        "title" character varying,
        "status" character varying NOT NULL DEFAULT 'active',
        "failedLoginAttempts" integer NOT NULL DEFAULT 0,
        "lastPasswordChange" TIMESTAMP,
        "preferences" json,
        CONSTRAINT "UQ_users_email" UNIQUE ("email"),
        CONSTRAINT "PK_users" PRIMARY KEY ("id")
      )
    `);

    // Create clients table
    await queryRunner.query(`
      CREATE TABLE "clients" (
        "id" SERIAL NOT NULL,
        "name" character varying NOT NULL,
        "industry" character varying,
        "email" character varying,
        "phone" character varying,
        "primaryContact" character varying,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "lastActivity" TIMESTAMP,
        "complianceScore" integer,
        "status" character varying NOT NULL DEFAULT 'active',
        "address" json,
        "size" character varying,
        "employeeCount" integer,
        "website" character varying,
        CONSTRAINT "PK_clients" PRIMARY KEY ("id")
      )
    `);

    // Create client_users table
    await queryRunner.query(`
      CREATE TABLE "client_users" (
        "id" SERIAL NOT NULL,
        "username" character varying NOT NULL,
        "email" character varying NOT NULL,
        "role" character varying NOT NULL,
        "clientId" integer NOT NULL,
        "firstName" character varying NOT NULL,
        "lastName" character varying NOT NULL,
        "title" character varying,
        "department" character varying,
        "phone" character varying,
        "isActive" boolean NOT NULL DEFAULT true,
        "lastActive" TIMESTAMP,
        "permissions" json,
        "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
        "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "PK_client_users" PRIMARY KEY ("id")
      )
    `);

    // Add foreign key constraint
    await queryRunner.query(`
      ALTER TABLE "client_users" 
      ADD CONSTRAINT "FK_client_users_clients" 
      FOREIGN KEY ("clientId") 
      REFERENCES "clients"("id") 
      ON DELETE CASCADE 
      ON UPDATE NO ACTION
    `);

    // Create indexes
    await queryRunner.query(`
      CREATE INDEX "IDX_users_email" ON "users" ("email")
    `);

    await queryRunner.query(`
      CREATE INDEX "IDX_client_users_clientId" ON "client_users" ("clientId")
    `);

    await queryRunner.query(`
      CREATE INDEX "IDX_client_users_email" ON "client_users" ("email")
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Drop foreign key constraint
    await queryRunner.query(`
      ALTER TABLE "client_users" DROP CONSTRAINT "FK_client_users_clients"
    `);

    // Drop indexes
    await queryRunner.query(`DROP INDEX "IDX_client_users_email"`);
    await queryRunner.query(`DROP INDEX "IDX_client_users_clientId"`);
    await queryRunner.query(`DROP INDEX "IDX_users_email"`);

    // Drop tables
    await queryRunner.query(`DROP TABLE "client_users"`);
    await queryRunner.query(`DROP TABLE "clients"`);
    await queryRunner.query(`DROP TABLE "users"`);
  }
}

================
File: migrations/1709575572000-SeedData.ts
================
import { MigrationInterface, QueryRunner } from 'typeorm';
import * as bcrypt from 'bcrypt';

export class SeedData1709575572000 implements MigrationInterface {
  name = 'SeedData1709575572000';

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Hash password for admin user
    const salt = await bcrypt.genSalt();
    const hashedPassword = await bcrypt.hash('Admin123!', salt);

    // Insert admin user
    await queryRunner.query(`
      INSERT INTO "users" (
        "email", 
        "password", 
        "firstName", 
        "lastName", 
        "role", 
        "isActive", 
        "createdAt", 
        "updatedAt", 
        "status", 
        "lastPasswordChange"
      ) VALUES (
        'admin@example.com', 
        '${hashedPassword}', 
        'Admin', 
        'User', 
        'admin', 
        true, 
        now(), 
        now(), 
        'active', 
        now()
      )
    `);

    // Insert sample client
    await queryRunner.query(`
      INSERT INTO "clients" (
        "name", 
        "industry", 
        "email", 
        "phone", 
        "primaryContact", 
        "createdAt", 
        "status", 
        "address", 
        "size", 
        "employeeCount", 
        "website"
      ) VALUES (
        'Acme Corporation', 
        'Technology', 
        'contact@acme.com', 
        '555-123-4567', 
        'John Smith', 
        now(), 
        'active', 
        '{"street": "123 Main St", "city": "San Francisco", "state": "CA", "zipCode": "94105", "country": "USA"}', 
        'Large', 
        1000, 
        'https://acme.example.com'
      )
    `);

    // Insert sample client user
    await queryRunner.query(`
      INSERT INTO "client_users" (
        "username", 
        "email", 
        "role", 
        "clientId", 
        "firstName", 
        "lastName", 
        "title", 
        "department", 
        "phone", 
        "isActive", 
        "permissions", 
        "createdAt", 
        "updatedAt"
      ) VALUES (
        'jsmith', 
        'john.smith@acme.com', 
        'manager', 
        1, 
        'John', 
        'Smith', 
        'IT Manager', 
        'Information Technology', 
        '555-987-6543', 
        true, 
        '["view", "edit", "approve"]', 
        now(), 
        now()
      )
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Delete sample data
    await queryRunner.query(`DELETE FROM "client_users" WHERE "email" = 'john.smith@acme.com'`);
    await queryRunner.query(`DELETE FROM "clients" WHERE "name" = 'Acme Corporation'`);
    await queryRunner.query(`DELETE FROM "users" WHERE "email" = 'admin@example.com'`);
  }
}

================
File: scripts/create-database.ts
================
import { Client } from 'pg';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config();

async function createDatabase() {
  const dbName = process.env.DB_DATABASE || 'grc_db';
  const client = new Client({
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432', 10),
    user: process.env.DB_USERNAME || 'postgres',
    password: process.env.POSTGRES_PASSWORD,
    database: 'postgres', // Connect to default postgres database
  });

  try {
    await client.connect();
    console.log('Connected to PostgreSQL server');

    // Check if database exists
    const checkResult = await client.query(
      "SELECT 1 FROM pg_database WHERE datname = $1",
      [dbName]
    );

    // Create database if it doesn't exist
    if (checkResult.rowCount === 0) {
      console.log(`Creating database: ${dbName}`);
      await client.query(`CREATE DATABASE ${dbName}`);
      console.log('Database created successfully');
    } else {
      console.log(`Database ${dbName} already exists`);
    }
  } catch (error) {
    console.error('Error creating database:', error);
    throw error;
  } finally {
    await client.end();
    console.log('Disconnected from PostgreSQL server');
  }
}

// Execute the function
createDatabase()
  .then(() => {
    console.log('Database setup completed');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Database setup failed:', error);
    process.exit(1);
  });

================
File: users/dto/create-user.dto.ts
================
import {
  IsEmail,
  IsNotEmpty,
  IsOptional,
  IsString,
  MinLength,
} from 'class-validator';

export class CreateUserDto {
  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @IsString()
  @MinLength(8)
  password: string;

  @IsNotEmpty()
  @IsString()
  firstName: string;

  @IsNotEmpty()
  @IsString()
  lastName: string;

  @IsNotEmpty()
  @IsString()
  role: string;

  @IsOptional()
  @IsString()
  phoneNumber?: string;

  @IsOptional()
  @IsString()
  department?: string;

  @IsOptional()
  @IsString()
  title?: string;
}

================
File: users/dto/update-user.dto.ts
================
import {
  IsEmail,
  IsOptional,
  IsString,
  MinLength,
  IsBoolean,
  IsNumber,
  Min,
  IsDate,
} from 'class-validator';
import { Type } from 'class-transformer';

export class UpdateUserDto {
  @IsOptional()
  @IsEmail()
  email?: string;

  @IsOptional()
  @IsString()
  @MinLength(8)
  password?: string;

  @IsOptional()
  @IsString()
  firstName?: string;

  @IsOptional()
  @IsString()
  lastName?: string;

  @IsOptional()
  @IsString()
  role?: string;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsString()
  profileImage?: string;

  @IsOptional()
  @IsString()
  phoneNumber?: string;

  @IsOptional()
  @IsString()
  department?: string;

  @IsOptional()
  @IsString()
  title?: string;

  @IsOptional()
  @IsString()
  status?: string;

  @IsOptional()
  @IsNumber()
  @Min(0)
  failedLoginAttempts?: number;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  lastLogin?: Date;

  @IsOptional()
  @Type(() => Date)
  @IsDate()
  lastPasswordChange?: Date;
}

================
File: users/entities/user.entity.ts
================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true })
  email: string;

  @Column()
  password: string;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column()
  role: string;

  @Column({ default: true })
  isActive: boolean;

  @Column({ nullable: true, type: 'timestamp' })
  lastLogin: Date;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @Column({ nullable: true })
  profileImage: string;

  @Column({ nullable: true })
  phoneNumber: string;

  @Column({ nullable: true })
  department: string;

  @Column({ nullable: true })
  title: string;

  @Column({ default: 'active' })
  status: string;

  @Column({ default: 0 })
  failedLoginAttempts: number;

  @Column({ nullable: true, type: 'timestamp' })
  lastPasswordChange: Date;

  @Column({ type: 'json', nullable: true })
  preferences: Record<string, unknown>;
}

================
File: users/users.controller.ts
================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';
import { ApiResponse } from '../common/interfaces/api-response.interface';
import { User } from './entities/user.entity';
import { UtilityService } from '../common/services/utility.service';
import { Roles } from '../common/decorators/roles.decorator';

@Controller('users')
export class UsersController {
  constructor(
    private readonly usersService: UsersService,
    private readonly utilityService: UtilityService,
  ) {}

  @Post()
  @Roles('admin')
  async create(@Body() createUserDto: CreateUserDto): Promise<ApiResponse<User>> {
    const user = await this.usersService.create(createUserDto);
    return this.utilityService.createSuccessResponse(
      user,
      'User created successfully',
    );
  }

  @Get()
  @Roles('admin')
  async findAll(@Query() paginationDto: PaginationDto): Promise<ApiResponse<{ users: User[]; total: number }>> {
    const [users, total] = await this.usersService.findAll(paginationDto);
    return this.utilityService.createSuccessResponse(
      { users, total },
      'Users retrieved successfully',
      {
        page: paginationDto.page,
        limit: paginationDto.limit,
        totalPages: Math.ceil(total / paginationDto.limit),
      },
    );
  }

  @Get(':id')
  @Roles('admin')
  async findOne(@Param('id') id: string): Promise<ApiResponse<User>> {
    const user = await this.usersService.findOne(+id);
    return this.utilityService.createSuccessResponse(
      user,
      'User retrieved successfully',
    );
  }

  @Patch(':id')
  @Roles('admin')
  async update(
    @Param('id') id: string,
    @Body() updateUserDto: UpdateUserDto,
  ): Promise<ApiResponse<User>> {
    const user = await this.usersService.update(+id, updateUserDto);
    return this.utilityService.createSuccessResponse(
      user,
      'User updated successfully',
    );
  }

  @Delete(':id')
  @Roles('admin')
  async remove(@Param('id') id: string): Promise<ApiResponse<null>> {
    await this.usersService.remove(+id);
    return this.utilityService.createSuccessResponse(
      null,
      'User deleted successfully',
    );
  }
}

================
File: users/users.module.ts
================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { User } from './entities/user.entity';
import { CommonModule } from '../common/common.module';

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    CommonModule,
  ],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}

================
File: users/users.service.ts
================
import {
  Injectable,
  NotFoundException,
  ConflictException,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { User } from './entities/user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { PaginationDto } from '../common/dto/pagination.dto';

@Injectable()
export class UsersService {
  private readonly logger = new Logger(UsersService.name);

  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<User> {
    try {
      // Check if user with email already exists
      const existingUser = await this.findByEmail(createUserDto.email);
      if (existingUser) {
        throw new ConflictException('Email already exists');
      }

      // Hash password
      const salt = await bcrypt.genSalt();
      const hashedPassword = await bcrypt.hash(createUserDto.password, salt);

      // Create new user
      const user = this.usersRepository.create({
        ...createUserDto,
        password: hashedPassword,
        lastPasswordChange: new Date(),
      });

      return await this.usersRepository.save(user);
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }
      this.logger.error(`Failed to create user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to create user');
    }
  }

  async findAll(paginationDto: PaginationDto): Promise<[User[], number]> {
    try {
      return await this.usersRepository.findAndCount({
        skip: paginationDto.skip,
        take: paginationDto.limit,
        order: {
          createdAt: 'DESC',
        },
      });
    } catch (error) {
      this.logger.error(`Failed to find users: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to find users');
    }
  }

  async findOne(id: number): Promise<User> {
    try {
      const user = await this.usersRepository.findOne({ where: { id } });
      if (!user) {
        throw new NotFoundException(`User with ID ${id} not found`);
      }
      return user;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to find user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to find user');
    }
  }

  async findByEmail(email: string): Promise<User | null> {
    try {
      return await this.usersRepository.findOne({ where: { email } });
    } catch (error) {
      this.logger.error(`Failed to find user by email: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to find user by email');
    }
  }

  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {
    try {
      const user = await this.findOne(id);

      // If password is being updated, hash it
      if (updateUserDto.password) {
        const salt = await bcrypt.genSalt();
        updateUserDto.password = await bcrypt.hash(updateUserDto.password, salt);
        user.lastPasswordChange = new Date();
      }

      // Update user
      Object.assign(user, updateUserDto);
      return await this.usersRepository.save(user);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to update user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to update user');
    }
  }

  async remove(id: number): Promise<void> {
    try {
      const result = await this.usersRepository.delete(id);
      if (result.affected === 0) {
        throw new NotFoundException(`User with ID ${id} not found`);
      }
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      this.logger.error(`Failed to remove user: ${(error as Error).message}`, (error as Error).stack);
      throw new InternalServerErrorException('Failed to remove user');
    }
  }
}



================================================================
End of Codebase
================================================================
