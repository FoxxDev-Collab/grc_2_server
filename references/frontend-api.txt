This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
BaseApiService.js
client/AssessmentApi.js
client/AssetManagementApi.js
client/AuditApi.js
client/ClientApi.js
client/ClientUserApi.js
client/IncidentApi.js
client/reportGenerationApi.js
client/ReportingApi.js
client/RiskAssessmentApi.js
client/SecurityAssessmentsApi.js
client/SecurityInitiativesApi.js
client/SecurityObjectivesApi.js
client/SecurityStrategyApi.js
grc/AuthApi.js
grc/GrcUserApi.js
grc/settingsApi.js
system/ArtifactsApi.js
system/AssessmentApi.js
system/AtoTrackerApi.js
system/AuthorizationApi.js
system/InitialAssessmentApi.js
system/SystemApi.js
system/SystemCategorizationApi.js
system/SystemComponentsApi.js
system/SystemControlsApi.js

================================================================
Files
================================================================

================
File: BaseApiService.js
================
// src/services/api/BaseApiService.js
import { get, post, put, patch, del, validateRequired } from '../utils/apiHelpers';
import { IS_MOCK, API_BASE_URL } from '../config';

/**
 * Utility function to create a delay with exponential backoff and jitter
 * @param {number} attempt - The current retry attempt (0-based)
 * @param {number} maxDelay - Maximum delay in milliseconds
 * @returns {Promise<void>} - Promise that resolves after the delay
 */
export const delay = (attempt = 0, maxDelay = 10000) => {
  const delayTime = Math.min(1000 * 2 ** attempt + Math.random() * 1000, maxDelay);
  return new Promise(resolve => setTimeout(resolve, delayTime));
};

/**
 * Custom API Error class to handle API-specific errors with additional context
 */
export class ApiError extends Error {
  constructor(message, status, code, data = null) {
    super(message);
    this.name = 'ApiError';
    this.status = status;       // HTTP status code
    this.code = code;           // Application-specific error code
    this.data = data;           // Additional error data
    this.timestamp = new Date().toISOString();
    
    // Maintains proper stack trace for debugging (V8 engines)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ApiError);
    }
  }

  /**
   * Create an ApiError from a response object
   * @param {Object} response - Response from fetch or similar
   * @param {Object} data - Response data 
   * @returns {ApiError} - Structured API error
   */
  static fromResponse(response, data) {
    const status = response.status;
    const message = data?.message || `API Error: ${status}`;
    const code = data?.code || `ERR_${status}`;
    
    return new ApiError(message, status, code, data);
  }

  /**
   * Create a network-related ApiError
   * @param {Error} originalError - The original error that occurred
   * @returns {ApiError} - Network error
   */
  static networkError(originalError) {
    return new ApiError(
      originalError.message || 'Network error occurred',
      0,
      'ERR_NETWORK',
      { originalError: originalError.toString() }
    );
  }

  /**
   * Create a timeout ApiError
   * @param {string} url - The URL that timed out
   * @returns {ApiError} - Timeout error
   */
  static timeoutError(url) {
    return new ApiError(
      `Request to ${url} timed out`,
      0,
      'ERR_TIMEOUT',
      { url }
    );
  }
}

export class BaseApiService {
  constructor(basePath, entityName, options = {}) {
    this.basePath = basePath;
    this.entityName = entityName;
    // When in mock mode, use the mock server URL
    this.baseUrl = IS_MOCK ? 'http://localhost:3001' : API_BASE_URL;
    
    // Default options
    this.options = {
      timeout: 30000,  // 30 second default timeout
      retries: 0,      // No retries by default
      ...options
    };
  }

  // Helper to build URL with path parameters
  buildUrl(path = '', pathParams = {}) {
    let url = `${this.basePath}${path}`;
    
    // Replace path parameters
    Object.entries(pathParams).forEach(([key, value]) => {
      url = url.replace(`:${key}`, encodeURIComponent(value));
    });
    
    return url;
  }

  /**
   * Handles API errors uniformly across all requests
   * @param {Error} error - The caught error
   * @param {string} operation - The operation that failed
   * @param {string} endpoint - The endpoint that was called
   * @throws {ApiError} - Rethrows a structured ApiError
   */
  handleError(error, operation, endpoint) {
    // If it's already an ApiError, just rethrow it
    if (error instanceof ApiError) {
      throw error;
    }
    
    // If it's a fetch Response error
    if (error.response) {
      throw ApiError.fromResponse(error.response, error.data);
    }

    // Check for timeout errors
    if (error.name === 'AbortError' || error.message?.includes('timeout')) {
      throw ApiError.timeoutError(`${endpoint}`);
    }
    
    // Handle network errors
    if (error.message?.includes('Network') || !navigator.onLine) {
      throw ApiError.networkError(error);
    }
    
    // Generic API error for all other cases
    throw new ApiError(
      `${this.entityName} ${operation} failed: ${error.message || 'Unknown error'}`,
      500,
      'ERR_INTERNAL',
      { originalError: error.toString() }
    );
  }

  /**
   * Execute a request with retry capability
   * @param {Function} requestFn - Function that performs the request
   * @param {string} operation - Name of the operation for error handling
   * @param {string} endpoint - API endpoint for error context
   * @returns {Promise<any>} - The API response
   */
  async executeRequest(requestFn, operation, endpoint) {
    let lastError;
    const maxRetries = this.options.retries;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await requestFn();
      } catch (error) {
        lastError = error;
        
        // Don't retry client errors (4xx)
        if (error instanceof ApiError && error.status >= 400 && error.status < 500) {
          break;
        }
        
        // Don't retry on last attempt
        if (attempt === maxRetries) {
          break;
        }
        
        // Exponential backoff with jitter
        await delay(attempt, 10000);
      }
    }
    
    this.handleError(lastError, operation, endpoint);
  }

  // CRUD operations with enhanced error handling and retry support
  async getAll(queryParams = {}) {
    const endpoint = this.basePath;
    return this.executeRequest(
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      () => get(endpoint, queryParams, { timeout: this.options.timeout }),
      'retrieval',
      endpoint
    );
  }

  async getById(id, queryParams = {}) {
    validateRequired({ id }, ['id']);
    const endpoint = `${this.basePath}/${id}`;
    return this.executeRequest(
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      () => get(endpoint, queryParams, { timeout: this.options.timeout }),
      'retrieval',
      endpoint
    );
  }

  async create(data) {
    const endpoint = this.basePath;
    return this.executeRequest(
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      () => post(endpoint, data, { timeout: this.options.timeout }),
      'creation',
      endpoint
    );
  }

  async update(id, data) {
    validateRequired({ id }, ['id']);
    const endpoint = `${this.basePath}/${id}`;
    return this.executeRequest(
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      () => put(endpoint, data, { timeout: this.options.timeout }),
      'update',
      endpoint
    );
  }

  async partialUpdate(id, data) {
    validateRequired({ id }, ['id']);
    const endpoint = `${this.basePath}/${id}`;
    return this.executeRequest(
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      () => patch(endpoint, data, { timeout: this.options.timeout }),
      'partial update',
      endpoint
    );
  }

  async delete(id) {
    validateRequired({ id }, ['id']);
    const endpoint = `${this.basePath}/${id}`;
    return this.executeRequest(
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      () => del(endpoint, { timeout: this.options.timeout }),
      'deletion',
      endpoint
    );
  }

  /**
   * Custom method for bulk operations
   * @param {Array} items - Items to process in bulk
   * @param {string} operation - The operation to perform ('create', 'update', 'delete')
   * @returns {Promise<Object>} - Results of the bulk operation
   */
  async bulkOperation(items, operation) {
    validateRequired({ items, operation }, ['items', 'operation']);
    
    if (!Array.isArray(items)) {
      throw new ApiError('Items must be an array', 400, 'ERR_INVALID_INPUT');
    }
    
    const endpoint = `${this.basePath}/bulk/${operation}`;
    return this.executeRequest(
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      () => post(endpoint, { items }, { timeout: this.options.timeout * 2 }),
      `bulk ${operation}`,
      endpoint
    );
  }
}

================
File: client/AssessmentApi.js
================
const API_URL = 'http://localhost:3001';

const handleError = (error) => {
  console.error('API Error:', error);
  throw error;
};

const assessmentApi = {
  // Assessment Plan APIs
  getAssessmentPlan: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentPlans?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch assessment plan');
      const plans = await response.json();
      return plans[0]; // Return the first matching plan
    } catch (error) {
      return handleError(error);
    }
  },

  updateAssessmentPlan: async (clientId, systemId, planData) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentPlans/${planData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...planData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update assessment plan');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Security Testing APIs
  getScanResults: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/scanResults?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch scan results');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  uploadScanResults: async (clientId, systemId, formData) => {
    try {
      const newScan = {
        id: `scan-${Date.now()}`,
        type: formData.get('type') || 'STIG Scan',
        date: new Date().toISOString(),
        findings: {
          high: parseInt(formData.get('highFindings') || '0'),
          medium: parseInt(formData.get('mediumFindings') || '0'),
          low: parseInt(formData.get('lowFindings') || '0')
        },
        status: 'Completed',
        downloadUrl: '#',
        detailsUrl: '#',
        clientId,
        systemId,
        assessmentPlanId: formData.get('assessmentPlanId'),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      const response = await fetch(
        `${API_URL}/scanResults`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(newScan)
        }
      );
      if (!response.ok) throw new Error('Failed to upload scan results');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  deleteScanResult: async (clientId, systemId, scanId) => {
    try {
      const response = await fetch(
        `${API_URL}/scanResults/${scanId}`,
        {
          method: 'DELETE'
        }
      );
      if (!response.ok) throw new Error('Failed to delete scan result');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Control Assessment APIs
  getControlAssessments: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/controls?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch control assessments');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  updateControlAssessment: async (clientId, systemId, controlData) => {
    try {
      const response = await fetch(
        `${API_URL}/controls/${controlData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...controlData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update control assessment');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Documentation Review APIs
  getDocumentationReview: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch documentation review');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  updateDocumentReview: async (clientId, systemId, documentData) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments/${documentData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...documentData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update document review');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  getDocumentDownloadUrl: async (clientId, systemId, documentId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments/${documentId}`
      );
      if (!response.ok) throw new Error('Failed to get document download URL');
      const doc = await response.json();
      return doc.downloadUrl || '#';
    } catch (error) {
      return handleError(error);
    }
  },
};

export default assessmentApi;

================
File: client/AssetManagementApi.js
================
// src/services/api/client/AssetManagementApi.js
import { BaseApiService } from '../BaseApiService';
import { validateRequired } from '../../utils/apiHelpers';
import { IS_MOCK } from '../../config';

// Asset types enum
export const AssetType = {
  LAPTOP: 'laptop',
  DESKTOP: 'desktop',
  TABLET: 'tablet',
  MOBILE_PHONE: 'mobile_phone',
  DESK_PHONE: 'desk_phone',
  NETWORK_DEVICE: 'network_device',
  SERVER: 'server',
  PRINTER: 'printer',
  OTHER: 'other'
};

// Asset status enum
export const AssetStatus = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  MAINTENANCE: 'maintenance',
  DISPOSED: 'disposed',
  LOST: 'lost',
  STOLEN: 'stolen'
};

class AssetManagementApi extends BaseApiService {
  constructor() {
    super('/assets', 'assets');
  }

  // Get all assets for a client
  async getAssets(clientId, queryParams = {}) {
    validateRequired({ clientId }, ['clientId']);
    return this.getAll({ 
      clientId: Number(clientId),
      ...queryParams 
    });
  }

  // Get a single asset
  async getAsset(clientId, assetId) {
    validateRequired({ clientId, assetId }, ['clientId', 'assetId']);
    return this.getById(assetId);
  }

  // Create a new asset
  async createAsset(clientId, assetData) {
    validateRequired({ clientId }, ['clientId']);
    validateRequired(assetData, ['type', 'name', 'model', 'serialNumber']);
    
    // Prepare the asset data with client ID
    const newAssetData = {
      ...assetData,
      clientId: Number(clientId),
      status: assetData.status || AssetStatus.ACTIVE,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    return this.create(newAssetData);
  }

  // Update an existing asset
  async updateAsset(clientId, assetId, assetData) {
    validateRequired({ clientId, assetId }, ['clientId', 'assetId']);
    
    // Prepare the update data
    const updateData = {
      ...assetData,
      clientId: Number(clientId),
      updatedAt: new Date().toISOString()
    };
    
    return this.update(assetId, updateData);
  }

  // Delete an asset
  async deleteAsset(clientId, assetId) {
    validateRequired({ clientId, assetId }, ['clientId', 'assetId']);
    return this.delete(assetId);
  }

  // Get asset types
  async getAssetTypes() {
    if (IS_MOCK) {
      return Object.entries(AssetType).map(([key, value]) => ({
        id: value,
        name: key.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase())
      }));
    }
    
    return this.executeRequest(
      () => this.get(`${this.basePath}/types`),
      'retrieval',
      `${this.basePath}/types`
    );
  }

  // Get asset statuses
  async getAssetStatuses() {
    if (IS_MOCK) {
      return Object.entries(AssetStatus).map(([key, value]) => ({
        id: value,
        name: key.replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase())
      }));
    }
    
    return this.executeRequest(
      () => this.get(`${this.basePath}/statuses`),
      'retrieval',
      `${this.basePath}/statuses`
    );
  }

  // Bulk import assets
  async bulkImportAssets(clientId, assetsData) {
    validateRequired({ clientId }, ['clientId']);
    
    if (!Array.isArray(assetsData) || assetsData.length === 0) {
      throw new Error('Assets data must be a non-empty array');
    }
    
    // Prepare the assets data with client ID and timestamps
    const preparedAssetsData = assetsData.map(asset => ({
      ...asset,
      clientId: Number(clientId),
      status: asset.status || AssetStatus.ACTIVE,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }));
    
    return this.bulkOperation(preparedAssetsData, 'create');
  }

  // Generate asset report
  async generateAssetReport(clientId, reportOptions = {}) {
    validateRequired({ clientId }, ['clientId']);
    
    if (IS_MOCK) {
      // Return mock report data
      return {
        generatedAt: new Date().toISOString(),
        totalAssets: 150,
        assetsByType: {
          laptop: 45,
          desktop: 30,
          mobile_phone: 35,
          tablet: 15,
          network_device: 20,
          other: 5
        },
        assetsByStatus: {
          active: 120,
          inactive: 10,
          maintenance: 15,
          disposed: 5
        },
        assetsNearingEndOfLife: 12,
        assetsNearingEndOfSupport: 18
      };
    }
    
    return this.executeRequest(
      () => this.post(`${this.basePath}/reports`, { clientId: Number(clientId), ...reportOptions }),
      'report generation',
      `${this.basePath}/reports`
    );
  }
}

export default new AssetManagementApi();

================
File: client/AuditApi.js
================
import { validateRequired } from '../../apiHelpers';
import riskAssessmentApi from '../../api/client/RiskAssessmentApi';

const API_URL = 'http://localhost:3001';

// Source types that map to different APIs
const SOURCE_TYPES = {
  SECURITY_ASSESSMENT: 'security_assessment',
  VULNERABILITY_SCAN: 'vulnerability_scan',
  COMPLIANCE_REVIEW: 'compliance_review',
  EXTERNAL_AUDIT: 'external_audit',
  INTERNAL_AUDIT: 'internal_audit',
  INCIDENT_REVIEW: 'incident_review'
};

const SEVERITY_LEVELS = ['critical', 'high', 'medium', 'low', 'informational'];
const FINDING_STATUSES = ['open', 'in_progress', 'closed', 'reopened', 'duplicate', 'deferred'];
const COMMON_TAGS = [
  'access-control',
  'authentication',
  'authorization',
  'configuration',
  'encryption',
  'network-security',
  'patch-management',
  'policy-violation',
  'security-controls',
  'third-party',
  'vulnerability'
];

export const auditApi = {
  // Get all findings by aggregating from different sources
  getFindings: async (clientId, filters = {}) => {
    validateRequired({ clientId }, ['clientId']);
    const numericClientId = Number(clientId);

    try {
      // Get all assessments for the client
      const response = await fetch(`${API_URL}/assessments?clientId=${numericClientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch assessments');
      }
      const assessments = await response.json();
      
      // Make sure assessments is an array
      if (!Array.isArray(assessments)) {
        console.error('Expected assessments to be an array, got:', typeof assessments);
        return [];
      }
      
      // Extract findings from all assessments
      let allFindings = assessments.flatMap(assessment => {
        if (!assessment || !assessment.generatedFindings) {
          return [];
        }
        
        // Handle both array and object formats for generatedFindings
        const findingsArray = Array.isArray(assessment.generatedFindings) 
          ? assessment.generatedFindings 
          : Object.values(assessment.generatedFindings);
        
        return findingsArray.map(finding => ({
          ...finding,
          sourceType: SOURCE_TYPES.SECURITY_ASSESSMENT,
          sourceDetails: `Security Assessment: ${assessment.name || 'Unknown'}`,
          createdDate: assessment.date || new Date().toISOString(),
          assessmentId: assessment.id
        }));
      });

      // Apply filters
      if (filters.sourceType) {
        allFindings = allFindings.filter(f => f.sourceType === filters.sourceType);
      }
      if (filters.severity) {
        allFindings = allFindings.filter(f => f.severity === filters.severity);
      }
      if (filters.status) {
        allFindings = allFindings.filter(f => f.status === filters.status);
      }
      if (filters.tags && filters.tags.length > 0) {
        allFindings = allFindings.filter(f => 
          filters.tags.some(tag => f.tags?.includes(tag))
        );
      }

      return allFindings;
    } catch (error) {
      throw new Error(`Failed to fetch findings: ${error.message}`);
    }
  },

  // Get finding metrics
  getFindingMetrics: async (clientId) => {
    try {
      const findings = await auditApi.getFindings(Number(clientId));

      return {
        total: findings.length,
        bySeverity: {
          critical: findings.filter(f => f.severity === 'critical').length,
          high: findings.filter(f => f.severity === 'high').length,
          medium: findings.filter(f => f.severity === 'medium').length,
          low: findings.filter(f => f.severity === 'low').length,
          informational: findings.filter(f => f.severity === 'informational').length
        },
        byStatus: {
          open: findings.filter(f => f.status === 'open').length,
          in_progress: findings.filter(f => f.status === 'in_progress').length,
          closed: findings.filter(f => f.status === 'closed').length,
          reopened: findings.filter(f => f.status === 'reopened').length,
          duplicate: findings.filter(f => f.status === 'duplicate').length,
          deferred: findings.filter(f => f.status === 'deferred').length,
          not_applicable: findings.filter(f => f.status === 'not_applicable').length
        },
        bySource: {
          security_assessment: findings.filter(f => f.sourceType === SOURCE_TYPES.SECURITY_ASSESSMENT).length,
          vulnerability_scan: findings.filter(f => f.sourceType === SOURCE_TYPES.VULNERABILITY_SCAN).length,
          compliance_review: findings.filter(f => f.sourceType === SOURCE_TYPES.COMPLIANCE_REVIEW).length,
          external_audit: findings.filter(f => f.sourceType === SOURCE_TYPES.EXTERNAL_AUDIT).length,
          internal_audit: findings.filter(f => f.sourceType === SOURCE_TYPES.INTERNAL_AUDIT).length,
          incident_review: findings.filter(f => f.sourceType === SOURCE_TYPES.INCIDENT_REVIEW).length
        },
        promotedToRisk: findings.filter(f => f.promotedToRisk).length
      };
    } catch (error) {
      throw new Error(`Failed to fetch finding metrics: ${error.message}`);
    }
  },

  // Get source types
  getSourceTypes: async () => {
    return Object.values(SOURCE_TYPES);
  },

  // Get severity levels
  getSeverityLevels: async () => {
    return [...SEVERITY_LEVELS];
  },

  // Get finding statuses
  getFindingStatuses: async () => {
    return [...FINDING_STATUSES];
  },

  // Get common tags
  getCommonTags: async () => {
    return [...COMMON_TAGS];
  },

  // Delete a finding
  deleteFinding: async (findingId, clientId) => {
    validateRequired({ findingId, clientId }, ['findingId', 'clientId']);
    
    try {
      // Find which assessment this finding belongs to
      let assessmentId;
      
      try {
        // Get all assessments for the client
        const response = await fetch(`${API_URL}/assessments?clientId=${Number(clientId)}`);
        if (!response.ok) {
          throw new Error('Failed to fetch assessments');
        }
        
        const assessments = await response.json();
        
        // Find the assessment that contains this finding
        for (const assessment of assessments) {
          if (assessment.generatedFindings) {
            // Handle both array and object formats
            const findings = Array.isArray(assessment.generatedFindings) 
              ? assessment.generatedFindings 
              : Object.values(assessment.generatedFindings);
              
            if (findings.some(f => f.id === findingId)) {
              assessmentId = assessment.id;
              break;
            }
          }
        }
      } catch (error) {
        console.warn('Error finding assessment for finding:', error);
        // Fallback to a default assessment ID based on the finding ID pattern
        assessmentId = findingId.includes('001') || findingId.includes('002') ? 
          'asmt-001' : 'asmt-002';
      }

      if (assessmentId) {
        // Get the current assessment
        const assessmentResponse = await fetch(`${API_URL}/assessments/${assessmentId}`);
        if (!assessmentResponse.ok) {
          throw new Error('Failed to fetch assessment');
        }
        
        const assessment = await assessmentResponse.json();
        
        // Remove the finding from the assessment
        let updatedFindings;
        
        if (Array.isArray(assessment.generatedFindings)) {
          // If generatedFindings is an array, filter out the finding
          updatedFindings = assessment.generatedFindings.filter(finding => finding.id !== findingId);
        } else {
          // If generatedFindings is an object, remove the finding from the object
          updatedFindings = { ...assessment.generatedFindings };
          delete updatedFindings[findingId];
        }
        
        // Update the assessment
        const updateResponse = await fetch(`${API_URL}/assessments/${assessmentId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            generatedFindings: updatedFindings
          })
        });

        if (!updateResponse.ok) {
          throw new Error('Failed to delete finding');
        }
        
        return { success: true };
      } else {
        throw new Error('Could not find assessment for this finding');
      }
    } catch (error) {
      throw new Error(`Failed to delete finding: ${error.message}`);
    }
  },

  // Update finding status
  updateFindingStatus: async (findingId, clientId, status) => {
    validateRequired({ findingId, clientId, status }, ['findingId', 'clientId', 'status']);
    
    try {
      // Find which assessment this finding belongs to
      let assessmentId;
      
      try {
        // Get all assessments for the client
        const response = await fetch(`${API_URL}/assessments?clientId=${Number(clientId)}`);
        if (!response.ok) {
          throw new Error('Failed to fetch assessments');
        }
        
        const assessments = await response.json();
        
        // Find the assessment that contains this finding
        for (const assessment of assessments) {
          if (assessment.generatedFindings) {
            // Handle both array and object formats
            const findings = Array.isArray(assessment.generatedFindings) 
              ? assessment.generatedFindings 
              : Object.values(assessment.generatedFindings);
              
            if (findings.some(f => f.id === findingId)) {
              assessmentId = assessment.id;
              break;
            }
          }
        }
      } catch (error) {
        console.warn('Error finding assessment for finding:', error);
        // Fallback to a default assessment ID based on the finding ID pattern
        assessmentId = findingId.includes('001') || findingId.includes('002') ? 
          'asmt-001' : 'asmt-002';
      }

      if (assessmentId) {
        // Get the current assessment
        const assessmentResponse = await fetch(`${API_URL}/assessments/${assessmentId}`);
        if (!assessmentResponse.ok) {
          throw new Error('Failed to fetch assessment');
        }
        
        const assessment = await assessmentResponse.json();
        
        // Update the finding status
        let updatedFindings;
        
        if (Array.isArray(assessment.generatedFindings)) {
          // If generatedFindings is an array, update the finding in the array
          updatedFindings = assessment.generatedFindings.map(finding => {
            if (finding.id === findingId) {
              return {
                ...finding,
                status: status
              };
            }
            return finding;
          });
        } else {
          // If generatedFindings is an object, update the finding in the object
          updatedFindings = { ...assessment.generatedFindings };
          if (updatedFindings[findingId]) {
            updatedFindings[findingId] = {
              ...updatedFindings[findingId],
              status: status
            };
          }
        }
        
        // Update the assessment
        const updateResponse = await fetch(`${API_URL}/assessments/${assessmentId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            generatedFindings: updatedFindings
          })
        });

        if (!updateResponse.ok) {
          throw new Error('Failed to update finding status');
        }
        
        return { success: true };
      } else {
        throw new Error('Could not find assessment for this finding');
      }
    } catch (error) {
      throw new Error(`Failed to update finding status: ${error.message}`);
    }
  },

  // Promote finding to risk
  promoteToRisk: async (findingId, riskData) => {
    validateRequired({ findingId, ...riskData }, ['findingId', 'name', 'description', 'impact', 'likelihood', 'category']);
    
    try {
      // Create a new risk assessment
      const risk = await riskAssessmentApi.createRisk(riskData.clientId, {
        name: riskData.name,
        description: riskData.description,
        impact: riskData.impact,
        likelihood: riskData.likelihood,
        category: riskData.category,
        source: `Finding: ${findingId}`,
        status: 'open',
        sourceFindings: [{
          findingId: findingId,
          title: riskData.name,
          sourceType: 'security_assessment',
          date: new Date().toISOString()
        }]
      });

      // Determine which assessment this finding belongs to
      let assessmentId;
      
      try {
        // Get all assessments for the client
        const response = await fetch(`${API_URL}/assessments?clientId=${Number(riskData.clientId)}`);
        if (!response.ok) {
          throw new Error('Failed to fetch assessments');
        }
        
        const assessments = await response.json();
        
        // Find the assessment that contains this finding
        for (const assessment of assessments) {
          if (assessment.generatedFindings) {
            // Handle both array and object formats
            const findings = Array.isArray(assessment.generatedFindings) 
              ? assessment.generatedFindings 
              : Object.values(assessment.generatedFindings);
              
            if (findings.some(f => f.id === findingId)) {
              assessmentId = assessment.id;
              break;
            }
          }
        }
      } catch (error) {
        console.warn('Error finding assessment for finding:', error);
        // Fallback to a default assessment ID based on the finding ID pattern
        assessmentId = findingId.includes('001') || findingId.includes('002') ? 
          'asmt-001' : 'asmt-002';
      }

      if (assessmentId) {
        // Get the current assessment
        const assessmentResponse = await fetch(`${API_URL}/assessments/${assessmentId}`);
        if (!assessmentResponse.ok) {
          throw new Error('Failed to fetch assessment');
        }
        
        const assessment = await assessmentResponse.json();
        
        // Update the finding in the assessment
        let updatedFindings;
        
        if (Array.isArray(assessment.generatedFindings)) {
          // If generatedFindings is an array, update the finding in the array
          updatedFindings = assessment.generatedFindings.map(finding => {
            if (finding.id === findingId) {
              return {
                ...finding,
                status: 'promoted_to_risk',
                riskId: risk.id,
                promotedToRisk: true
              };
            }
            return finding;
          });
        } else {
          // If generatedFindings is an object, update the finding in the object
          updatedFindings = { ...assessment.generatedFindings };
          if (updatedFindings[findingId]) {
            updatedFindings[findingId] = {
              ...updatedFindings[findingId],
              status: 'promoted_to_risk',
              riskId: risk.id,
              promotedToRisk: true
            };
          }
        }
        
        // Update the assessment
        const updateResponse = await fetch(`${API_URL}/assessments/${assessmentId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            generatedFindings: updatedFindings
          })
        });

        if (!updateResponse.ok) {
          throw new Error('Failed to update finding promotion status');
        }
      }

      // Also update the findings_to_risk mapping
      try {
        const mappingResponse = await fetch(`${API_URL}/findings_to_risk/assessmentFindings`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            assessmentId: assessmentId || 'unknown',
            findingId: findingId,
            status: 'promoted_to_risk',
            riskId: risk.id,
            promotedToRisk: true
          })
        });

        if (!mappingResponse.ok) {
          console.warn('Failed to update findings_to_risk mapping, but risk was created');
        }
      } catch (mappingError) {
        console.warn('Error updating findings_to_risk mapping:', mappingError);
      }

      return { success: true, riskId: risk.id };
    } catch (error) {
      throw new Error(`Failed to promote finding to risk: ${error.message}`);
    }
  }
};

export default auditApi;

================
File: client/ClientApi.js
================
/* eslint-disable no-unused-vars */
// src/services/api/client/ClientApi.js
import { validateRequired, validateEmail, get, post, put, del } from '../../utils/apiHelpers';
import { IS_MOCK } from '../../config';

// Define direct API URL constant (matching AuditApi.js approach)
const API_URL = 'http://localhost:3001';

// Helper function to get current date in ISO format
const getCurrentDate = () => new Date().toISOString();

class ClientApi {
  constructor() {
    this.endpoint = '/clients';
  }

  // Get all clients
  async getClients() {
    try {
      const response = await fetch(`${API_URL}${this.endpoint}`);
      if (!response.ok) {
        throw new Error('Failed to fetch clients');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch clients: ${error.message}`);
    }
  }

  // Get client by ID
  async getClient(id) {
    const numericId = Number(id);
    try {
      const response = await fetch(`${API_URL}${this.endpoint}/${numericId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch client');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch client: ${error.message}`);
    }
  }

  // Create new client
  async createClient(clientData) {
    validateRequired(clientData, ['name', 'industry', 'email', 'phone', 'primaryContact']);
    validateEmail(clientData.email);

    const newClient = {
      ...clientData,
      createdAt: getCurrentDate(),
      lastActivity: getCurrentDate(),
      complianceScore: 0,
      status: 'active',
      address: clientData.address || {
        street: '',
        city: '',
        state: '',
        zip: '',
        country: ''
      },
      size: clientData.size || '',
      employeeCount: clientData.employeeCount || 0,
      website: clientData.website || ''
    };

    try {
      const response = await fetch(`${API_URL}${this.endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newClient)
      });
      
      if (!response.ok) {
        throw new Error('Failed to create client');
      }
      
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to create client: ${error.message}`);
    }
  }

  // Update client
  async updateClient(id, updates) {
    const numericId = Number(id);
    
    if (updates.email) {
      validateEmail(updates.email);
    }

    try {
      // Get current client data
      const currentClient = await this.getClient(numericId);

      const updatedClient = {
        ...currentClient,
        ...updates,
        lastActivity: getCurrentDate()
      };

      const response = await fetch(`${API_URL}${this.endpoint}/${numericId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedClient)
      });
      
      if (!response.ok) {
        throw new Error('Failed to update client');
      }
      
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to update client: ${error.message}`);
    }
  }

  // Delete client
  async deleteClient(id) {
    const numericId = Number(id);
    try {
      const response = await fetch(`${API_URL}${this.endpoint}/${numericId}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error('Failed to delete client');
      }
      
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to delete client: ${error.message}`);
    }
  }

  // Get client compliance overview
  async getClientCompliance(id) {
    const numericId = Number(id);
    
    try {
      const client = await this.getClient(numericId);
      
      return {
        clientId: numericId,
        overallScore: client.complianceScore,
        lastUpdated: client.lastActivity,
        frameworks: {
          nist: 85,
          hipaa: 90,
          pci: 88
        }
      };
    } catch (error) {
      throw new Error(`Failed to get client compliance: ${error.message}`);
    }
  }

  // Get available industries
  async getIndustries() {
    if (IS_MOCK) {
      return [
        'Technology',
        'Healthcare',
        'Finance',
        'Manufacturing',
        'Retail',
        'Education',
        'Government',
        'Non-profit',
        'Other'
      ];
    }
    
    try {
      const response = await fetch(`${API_URL}${this.endpoint}/industries`);
      if (!response.ok) {
        throw new Error('Failed to fetch industries');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch industries: ${error.message}`);
    }
  }

  // Get available client sizes
  async getClientSizes() {
    if (IS_MOCK) {
      return [
        'Small (1-50 employees)',
        'Medium (51-500 employees)',
        'Large (501-5000 employees)',
        'Enterprise (5000+ employees)'
      ];
    }
    
    try {
      const response = await fetch(`${API_URL}${this.endpoint}/clientSizes`);
      if (!response.ok) {
        throw new Error('Failed to fetch client sizes');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch client sizes: ${error.message}`);
    }
  }

  // Get available client statuses
  async getClientStatuses() {
    if (IS_MOCK) {
      return [
        'active',
        'inactive',
        'pending',
        'suspended'
      ];
    }
    
    try {
      const response = await fetch(`${API_URL}${this.endpoint}/clientStatuses`);
      if (!response.ok) {
        throw new Error('Failed to fetch client statuses');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch client statuses: ${error.message}`);
    }
  }

  // Department Management
  async getDepartments(clientId) {
    const numericClientId = Number(clientId);
    
    try {
      // Changed from /clients/departments to /departments to match the server's endpoint structure
      const response = await fetch(`${API_URL}/departments?clientId=${numericClientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch departments');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch departments: ${error.message}`);
    }
  }

  async createDepartment(clientId, departmentData) {
    validateRequired(departmentData, ['name', 'head', 'headTitle']);

    const newDepartment = {
      clientId: Number(clientId),
      ...departmentData,
      employeeCount: departmentData.employeeCount || 0,
      positions: departmentData.positions || [],
      lastUpdated: getCurrentDate()
    };

    // Ensure positions have proper structure
    if (newDepartment.positions.length > 0) {
      newDepartment.positions = newDepartment.positions.map((position, index) => ({
        id: position.id || index + 1,
        name: position.name
      }));
    }

    try {
      // Changed from /clients/departments to /departments to match the server's endpoint structure
      const response = await fetch(`${API_URL}/departments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newDepartment)
      });
      
      if (!response.ok) {
        throw new Error('Failed to create department');
      }
      
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to create department: ${error.message}`);
    }
  }

  async updateDepartment(clientId, departmentId, updates) {
    const numericClientId = Number(clientId);
    const numericDepartmentId = Number(departmentId);

    try {
      // Get current department data
      // Changed from /clients/departments to /departments to match the server's endpoint structure
      const response = await fetch(`${API_URL}/departments/${numericDepartmentId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch department');
      }
      const currentDepartment = await response.json();

      // Verify department belongs to client
      if (currentDepartment.clientId !== numericClientId) {
        throw new Error('Department not found');
      }

      // Handle positions update
      let positions = currentDepartment.positions;
      if (updates.positions) {
        positions = updates.positions.map((position, index) => ({
          id: position.id || index + 1,
          name: position.name
        }));
      }

      const updatedDepartment = {
        ...currentDepartment,
        ...updates,
        positions,
        clientId: numericClientId,
        lastUpdated: getCurrentDate()
      };

      // Changed from /clients/departments to /departments to match the server's endpoint structure
      const updateResponse = await fetch(`${API_URL}/departments/${numericDepartmentId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedDepartment)
      });
      
      if (!updateResponse.ok) {
        throw new Error('Failed to update department');
      }
      
      return await updateResponse.json();
    } catch (error) {
      throw new Error(`Failed to update department: ${error.message}`);
    }
  }

  async deleteDepartment(clientId, departmentId) {
    const numericClientId = Number(clientId);
    const numericDepartmentId = Number(departmentId);

    try {
      // Verify department belongs to client before deletion
      // Changed from /clients/departments to /departments to match the server's endpoint structure
      const response = await fetch(`${API_URL}/departments/${numericDepartmentId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch department');
      }
      const department = await response.json();
      
      if (department.clientId !== numericClientId) {
        throw new Error('Department not found');
      }

      // Changed from /clients/departments to /departments to match the server's endpoint structure
      const deleteResponse = await fetch(`${API_URL}/departments/${numericDepartmentId}`, {
        method: 'DELETE'
      });
      
      if (!deleteResponse.ok) {
        throw new Error('Failed to delete department');
      }
      
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to delete department: ${error.message}`);
    }
  }

  // Document Management
  async getDocumentCategories() {
    if (IS_MOCK) {
      return [
        'General',
        'Policies',
        'Procedures',
        'Contracts',
        'Reports',
        'Compliance',
        'Security',
        'Other'
      ];
    }
    
    try {
      const response = await fetch(`${API_URL}${this.endpoint}/documentCategories`);
      if (!response.ok) {
        throw new Error('Failed to fetch document categories');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch document categories: ${error.message}`);
    }
  }

  async getDocumentTypes() {
    if (IS_MOCK) {
      return [
        'PDF',
        'DOCX',
        'XLSX',
        'PPTX',
        'TXT',
        'CSV',
        'ZIP',
        'JPG',
        'PNG'
      ];
    }
    
    try {
      const response = await fetch(`${API_URL}${this.endpoint}/documentTypes`);
      if (!response.ok) {
        throw new Error('Failed to fetch document types');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch document types: ${error.message}`);
    }
  }

  async getCompanyDocuments(clientId) {
    const numericClientId = Number(clientId);
    
    try {
      // Changed from /clients/documents to /documents to match the server's endpoint structure
      const response = await fetch(`${API_URL}/documents?clientId=${numericClientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch documents');
      }
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to fetch documents: ${error.message}`);
    }
  }

  async uploadDocument(clientId, formData) {
    const file = formData.get('file');
    if (!file) {
      throw new Error('No file provided');
    }

    const fileType = file.name.split('.').pop().toUpperCase();
    const documentTypes = await this.getDocumentTypes();
    const validTypes = Array.isArray(documentTypes) ? documentTypes : documentTypes.map(type => type.name);
    
    if (!validTypes.includes(fileType)) {
      throw new Error('Unsupported file type');
    }

    const newDocument = {
      clientId: Number(clientId),
      name: file.name,
      type: fileType,
      lastUpdated: getCurrentDate(),
      category: formData.get('category') || 'General',
      size: file.size,
      uploadedBy: 'Current User' // This should be replaced with actual user info from auth context
    };

    try {
      // Changed from /clients/documents to /documents to match the server's endpoint structure
      const response = await fetch(`${API_URL}/documents`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newDocument)
      });
      
      if (!response.ok) {
        throw new Error('Failed to upload document');
      }
      
      return await response.json();
    } catch (error) {
      throw new Error(`Failed to upload document: ${error.message}`);
    }
  }

  async downloadDocument(clientId, documentId) {
    const numericClientId = Number(clientId);
    const numericDocumentId = Number(documentId);

    try {
      // Verify document exists and belongs to client
      // Changed from /clients/documents to /documents to match the server's endpoint structure
      const response = await fetch(`${API_URL}/documents/${numericDocumentId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch document');
      }
      const document = await response.json();
      
      if (document.clientId !== numericClientId) {
        throw new Error('Document not found');
      }

      // In a real implementation, this would handle file download
      return { success: true, message: 'Document download initiated' };
    } catch (error) {
      throw new Error(`Failed to download document: ${error.message}`);
    }
  }

  async deleteDocument(clientId, documentId) {
    const numericClientId = Number(clientId);
    const numericDocumentId = Number(documentId);

    try {
      // Verify document belongs to client before deletion
      // Changed from /clients/documents to /documents to match the server's endpoint structure
      const response = await fetch(`${API_URL}/documents/${numericDocumentId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch document');
      }
      const document = await response.json();
      
      if (document.clientId !== numericClientId) {
        throw new Error('Document not found');
      }

      const deleteResponse = await fetch(`${API_URL}/documents/${numericDocumentId}`, {
        method: 'DELETE'
      });
      
      if (!deleteResponse.ok) {
        throw new Error('Failed to delete document');
      }
      
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to delete document: ${error.message}`);
    }
  }
}

export default new ClientApi();

================
File: client/ClientUserApi.js
================
/* eslint-disable no-unused-vars */
import { validateRequired, validateEmail, ApiError, fetchWithAuth } from '../../utils/apiHelpers';
import { API_BASE_URL } from '../../config';

// Helper function for API calls
const fetchApi = async (endpoint, options = {}) => {
  const response = await fetch(`${API_BASE_URL}/${endpoint}`, {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    },
    ...options
  });

  if (!response.ok) {
    throw new ApiError(`API Error: ${response.statusText}`, response.status);
  }

  return response.json();
};

// Login user
export const login = async ({ email, password }) => {
  validateRequired({ email, password }, ['email', 'password']);
  validateEmail(email);

  const users = await fetchApi(`users?email=${encodeURIComponent(email)}`);
  const user = users[0];

  if (!user || password !== 'admin123') { // Mock password check
    throw new ApiError('Invalid email or password', 401);
  }

  const token = `mock-token-${Date.now()}`;

  return {
    user: {
      id: user.id,
      email: user.email,
      username: user.username,
      role: user.role,
      permissions: user.permissions,
      clientId: Number(user.clientId)
    },
    token
  };
};

// Get all users
export const getUsers = async (clientId = null) => {
  const endpoint = clientId !== null 
    ? `users?clientId=${encodeURIComponent(clientId)}`
    : 'users';
  const users = await fetchApi(endpoint);
  return users.map(user => ({
    ...user,
    clientId: user.clientId !== null ? Number(user.clientId) : null
  }));
};

// Get available roles
export const getRoles = async () => {
  try {
    const roles = await fetchApi('roles');
    return roles;
  } catch (error) {
    console.error('Error fetching roles:', error);
    return [];
  }
};

// Get available permissions
export const getPermissions = async () => {
  try {
    const permissions = await fetchApi('permissions');
    return permissions;
  } catch (error) {
    console.error('Error fetching permissions:', error);
    return [];
  }
};

// Get available departments
export const getDepartments = async () => {
  try {
    const departments = await fetchApi('departments');
    return departments;
  } catch (error) {
    console.error('Error fetching departments:', error);
    return [];
  }
};

// Get available titles
export const getTitles = async () => {
  try {
    const titles = await fetchApi('titles');
    return titles;
  } catch (error) {
    console.error('Error fetching titles:', error);
    return [];
  }
};

// Get user statuses
export const getUserStatuses = async () => {
  try {
    const statuses = await fetchApi('userStatus');
    return statuses;
  } catch (error) {
    console.error('Error fetching user statuses:', error);
    return [];
  }
};

// Get user by ID
export const getUser = async (id) => {
  const user = await fetchApi(`users/${id}`);
  return {
    ...user,
    clientId: user.clientId !== null ? Number(user.clientId) : null
  };
};

// Create new user
export const createUser = async (userData) => {
  validateRequired(userData, ['username', 'email', 'role', 'clientId']);
  validateEmail(userData.email);

  try {
    // Validate role exists
    const roles = await getRoles();
    if (!roles.some(role => role.id === userData.role)) {
      throw new ApiError('Invalid role specified', 400);
    }

    // Check for existing email
    const existingUsers = await fetchApi(`users?email=${encodeURIComponent(userData.email)}`);
    if (existingUsers.length > 0) {
      throw new ApiError('Email already exists', 400);
    }

    // Get role permissions
    const rolePermissions = await fetchApi(`rolePermissions?id=${encodeURIComponent(userData.role)}`);
    const permissions = rolePermissions[0]?.permissions || ['view'];

    const newUser = {
      ...userData,
      clientId: userData.clientId !== null ? Number(userData.clientId) : null,
      isActive: true,
      lastActive: new Date().toISOString(),
      permissions
    };

    return fetchApi('users', {
      method: 'POST',
      body: JSON.stringify(newUser)
    });
  } catch (error) {
    console.error('Error creating user:', error);
    throw error;
  }
};

// Update user
export const updateUser = async (id, updates) => {
  if (updates.email) {
    validateEmail(updates.email);
    // Check if email is taken by another user
    const existingUsers = await fetchApi(`users?email=${encodeURIComponent(updates.email)}`);
    if (existingUsers.some(u => u.id !== id)) {
      throw new ApiError('Email already exists', 400);
    }
  }

  try {
    // Update permissions if role is changed
    if (updates.role) {
      const roles = await getRoles();
      if (!roles.some(role => role.id === updates.role)) {
        throw new ApiError('Invalid role specified', 400);
      }
      const rolePermissions = await fetchApi(`rolePermissions?id=${encodeURIComponent(updates.role)}`);
      updates.permissions = rolePermissions[0]?.permissions || ['view'];
    }

    // Convert clientId to number if it's being updated
    if (updates.clientId !== undefined) {
      updates.clientId = updates.clientId !== null ? Number(updates.clientId) : null;
    }

    const updatedUser = {
      ...updates,
      lastActive: new Date().toISOString()
    };

    return fetchApi(`users/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(updatedUser)
    });
  } catch (error) {
    console.error('Error updating user:', error);
    throw error;
  }
};

// Delete user
export const deleteUser = async (id) => {
  await fetchApi(`users/${id}`, { method: 'DELETE' });
  return { success: true, message: 'User deleted successfully' };
};

// Get user permissions
export const getUserPermissions = async (id) => {
  const user = await getUser(id);
  return {
    userId: id,
    role: user.role,
    permissions: user.permissions,
    clientId: user.clientId !== null ? Number(user.clientId) : null,
    lastUpdated: user.lastActive
  };
};

// Check if user has specific permission
export const hasPermission = async (userId, permission, clientId = null) => {
  try {
    const user = await getUser(userId);
    if (!user) return false;

    // System admins have all permissions
    if (user.role === 'SYSTEM_ADMIN') return true;

    // For client users, check if they're accessing their own client
    if (clientId !== null) {
      const numericClientId = Number(clientId);
      if (user.clientId !== numericClientId) return false;
    }

    return user.permissions.includes(permission) || user.permissions.includes('all');
  } catch {
    console.error(`Failed to check permissions for user ${userId}`);
    return false;
  }
};

// Export all functions as a default object
const clientUserApi = {
  login,
  getUsers,
  getRoles,
  getPermissions,
  getDepartments,
  getTitles,
  getUserStatuses,
  getUser,
  createUser,
  updateUser,
  deleteUser,
  getUserPermissions,
  hasPermission
};

export default clientUserApi;

================
File: client/IncidentApi.js
================
import { fetchWithAuth, validateRequired } from '../../utils/apiHelpers';

const DEFAULT_STATS = {
  total: 0,
  active: 0,
  resolved: 0,
  avgResolutionTime: 0,
  bySeverity: {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0
  },
  byType: {}
};

const incidentApi = {
  // Get all incidents
  getIncidents: async (clientId) => {
    try {
      const response = await fetchWithAuth(`/incidents?clientId=${clientId}`);
      return response;
    } catch (error) {
      console.error('Error fetching incidents:', error);
      throw new Error('Failed to fetch incidents');
    }
  },

  // Get single incident
  getIncident: async (clientId, incidentId) => {
    try {
      const response = await fetchWithAuth(`/incidents/${incidentId}?clientId=${clientId}`);
      return response;
    } catch (error) {
      console.error('Error fetching incident:', error);
      if (error.status === 404) throw new Error('Incident not found');
      throw new Error('Failed to fetch incident');
    }
  },

  // Create new incident
  createIncident: async (clientId, incidentData) => {
    try {
      validateRequired(incidentData, ['title', 'type', 'severity', 'priority', 'description']);

      const response = await fetchWithAuth('/incidents', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...incidentData,
          clientId: Number(clientId),
          status: 'active',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          resolvedAt: null,
          actions: []
        })
      });
      
      return response;
    } catch (error) {
      console.error('Error creating incident:', error);
      throw new Error('Failed to create incident');
    }
  },

  // Update incident
  updateIncident: async (clientId, incidentId, updates) => {
    try {
      const response = await fetchWithAuth(`/incidents/${incidentId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...updates,
          clientId: Number(clientId),
          updatedAt: new Date().toISOString(),
          // If status is being updated to 'resolved', set resolvedAt
          ...(updates.status === 'resolved' ? { resolvedAt: new Date().toISOString() } : {})
        })
      });
      
      return response;
    } catch (error) {
      console.error('Error updating incident:', error);
      if (error.status === 404) throw new Error('Incident not found');
      throw new Error('Failed to update incident');
    }
  },

  // Add action to incident
  addAction: async (clientId, incidentId, actionData) => {
    try {
      validateRequired(actionData, ['type', 'description', 'performedBy']);

      const incident = await incidentApi.getIncident(clientId, incidentId);
      const newAction = {
        id: Math.max(0, ...incident.actions.map(a => a.id)) + 1,
        timestamp: new Date().toISOString(),
        ...actionData
      };

      // eslint-disable-next-line no-unused-vars
      const response = await fetchWithAuth(`/incidents/${incidentId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          actions: [...incident.actions, newAction],
          updatedAt: new Date().toISOString()
        })
      });
      
      return newAction;
    } catch (error) {
      console.error('Error adding action:', error);
      throw new Error('Failed to add action');
    }
  },

  // Get incident types
  getIncidentTypes: async () => {
    try {
      const response = await fetchWithAuth('/incidentTypes');
      return response;
    } catch (error) {
      console.error('Error fetching incident types:', error);
      throw new Error('Failed to fetch incident types');
    }
  },

  // Get incident severities
  getIncidentSeverities: async () => {
    try {
      const response = await fetchWithAuth('/incidentSeverities');
      return response;
    } catch (error) {
      console.error('Error fetching incident severities:', error);
      throw new Error('Failed to fetch incident severities');
    }
  },

  // Get incident statuses
  getIncidentStatuses: async () => {
    try {
      const response = await fetchWithAuth('/incidentStatuses');
      return response;
    } catch (error) {
      console.error('Error fetching incident statuses:', error);
      throw new Error('Failed to fetch incident statuses');
    }
  },

  // Get incident priorities
  getIncidentPriorities: async () => {
    try {
      const response = await fetchWithAuth('/incidentPriorities');
      return response;
    } catch (error) {
      console.error('Error fetching incident priorities:', error);
      throw new Error('Failed to fetch incident priorities');
    }
  },

  // Get action types
  getActionTypes: async () => {
    try {
      const response = await fetchWithAuth('/actionTypes');
      return response;
    } catch (error) {
      console.error('Error fetching action types:', error);
      throw new Error('Failed to fetch action types');
    }
  },

  // Get teams
  getTeams: async () => {
    try {
      const response = await fetchWithAuth('/teams');
      return response;
    } catch (error) {
      console.error('Error fetching teams:', error);
      throw new Error('Failed to fetch teams');
    }
  },

  // Get system types
  getSystemTypes: async () => {
    try {
      const response = await fetchWithAuth('/systemTypes');
      return response;
    } catch (error) {
      console.error('Error fetching system types:', error);
      throw new Error('Failed to fetch system types');
    }
  },

  // Get incident statistics
  getIncidentStats: async (clientId) => {
    try {
      const [incidents, incidentTypes] = await Promise.all([
        incidentApi.getIncidents(clientId),
        incidentApi.getIncidentTypes()
      ]);
      
      if (!Array.isArray(incidents) || incidents.length === 0) {
        return {
          ...DEFAULT_STATS,
          byType: incidentTypes.reduce((acc, type) => ({ ...acc, [type]: 0 }), {})
        };
      }

      const activeIncidents = incidents.filter(inc => inc.status === 'active');
      const resolvedIncidents = incidents.filter(inc => inc.status === 'resolved');

      // Calculate average resolution time for resolved incidents
      const avgResolutionTime = resolvedIncidents.length ? 
        resolvedIncidents.reduce((acc, inc) => {
          const resolutionTime = new Date(inc.resolvedAt) - new Date(inc.createdAt);
          return acc + resolutionTime;
        }, 0) / resolvedIncidents.length : 0;

      return {
        total: incidents.length,
        active: activeIncidents.length,
        resolved: resolvedIncidents.length,
        avgResolutionTime: Math.round(avgResolutionTime / (1000 * 60 * 60)), // Convert to hours
        bySeverity: {
          critical: incidents.filter(inc => inc.severity === 'critical').length,
          high: incidents.filter(inc => inc.severity === 'high').length,
          medium: incidents.filter(inc => inc.severity === 'medium').length,
          low: incidents.filter(inc => inc.severity === 'low').length
        },
        byType: incidentTypes.reduce((acc, type) => ({
          ...acc,
          [type]: incidents.filter(inc => inc.type === type).length
        }), {})
      };
    } catch (error) {
      console.error('Error getting incident stats:', error);
      return DEFAULT_STATS;
    }
  }
};

export default incidentApi;

================
File: client/reportGenerationApi.js
================
import { delay } from '../../apiHelpers';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';

const reportGenerationApi = {
  generateExecutiveReport: async (data) => {
    await delay(1000); // Simulate processing time

    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    
    // Title
    doc.setFontSize(20);
    doc.text('Executive Security Report', pageWidth / 2, 20, { align: 'center' });
    
    // Client Info
    doc.setFontSize(12);
    doc.text(`Client: ${data.client.name}`, 20, 40);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 50);
    
    // Overall Score
    doc.setFontSize(16);
    doc.text('Overall Security Score', pageWidth / 2, 70, { align: 'center' });
    doc.setFontSize(24);
    doc.text(`${data.overallScore}%`, pageWidth / 2, 85, { align: 'center' });
    
    // Summary Section
    doc.setFontSize(14);
    doc.text('Security Summary', 20, 105);
    doc.setFontSize(10);
    doc.autoTable({
      startY: 110,
      head: [['Category', 'Metric', 'Value']],
      body: [
        ['Assessments', 'Average Score', `${data.summary.assessments.averageScore}%`],
        ['', 'Total Assessments', data.summary.assessments.total],
        ['Findings', 'Open Findings', data.summary.findings.open],
        ['', 'Critical Findings', data.summary.findings.critical],
        ['', 'Total Findings', data.summary.findings.total],
        ['Risks', 'Active Risks', data.summary.risks.active],
        ['', 'High Impact Risks', data.summary.risks.critical],
        ['', 'Total Risks', data.summary.risks.total]
      ]
    });

    // Systems Overview
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Systems Overview', 20, 20);
    doc.setFontSize(10);
    
    const systemsData = data.systems.map(system => [
      system.name,
      system.type,
      system.category,
      system.securityLevel,
      `${system.compliance.nist || 0}%`
    ]);

    doc.autoTable({
      startY: 30,
      head: [['System Name', 'Type', 'Category', 'Security Level', 'NIST Compliance']],
      body: systemsData
    });

    // Risk Analysis
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Risk Analysis', 20, 20);
    doc.setFontSize(10);

    const riskData = data.risks.map(risk => [
      risk.name,
      risk.category,
      risk.impact,
      risk.likelihood,
      risk.status
    ]);

    doc.autoTable({
      startY: 30,
      head: [['Risk Name', 'Category', 'Impact', 'Likelihood', 'Status']],
      body: riskData
    });

    // Recent Activity
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Recent Activity', 20, 20);
    doc.setFontSize(10);

    const activityData = data.recentActivity.map(activity => [
      activity.type,
      activity.title,
      new Date(activity.date).toLocaleDateString(),
      activity.status
    ]);

    doc.autoTable({
      startY: 30,
      head: [['Type', 'Title', 'Date', 'Status']],
      body: activityData
    });

    // Recommendations
    doc.addPage();
    doc.setFontSize(14);
    doc.text('Recommendations', 20, 20);
    doc.setFontSize(10);

    // Generate recommendations based on data
    const recommendations = [
      data.summary.findings.critical > 0 && {
        priority: 'High',
        area: 'Security Findings',
        recommendation: `Address ${data.summary.findings.critical} critical security findings`
      },
      data.summary.risks.active > 0 && {
        priority: 'High',
        area: 'Risk Management',
        recommendation: `Mitigate ${data.summary.risks.active} active security risks`
      },
      data.summary.assessments.averageScore < 80 && {
        priority: 'Medium',
        area: 'Security Assessments',
        recommendation: 'Improve security assessment scores through remediation efforts'
      }
    ].filter(Boolean);

    doc.autoTable({
      startY: 30,
      head: [['Priority', 'Area', 'Recommendation']],
      body: recommendations.map(r => [r.priority, r.area, r.recommendation])
    });

    return doc;
  }
};

export default reportGenerationApi;

================
File: client/ReportingApi.js
================
import { delay } from '../../api/BaseApiService';
import auditApi from './AuditApi';
import riskAssessmentApi from '../../api/client/RiskAssessmentApi';
import securityAssessmentsApi from './SecurityAssessmentsApi';

const reportingApi = {
  // Get executive dashboard data
  getExecutiveDashboard: async (clientId) => {
    await delay(600);
    const [
      findings,
      risks,
      assessments,
      findingMetrics,
      riskStats
    ] = await Promise.all([
      auditApi.getFindings(clientId),
      riskAssessmentApi.getRisks(clientId),
      securityAssessmentsApi.getAssessments(clientId),
      auditApi.getFindingMetrics(clientId),
      riskAssessmentApi.getRiskStats(clientId)
    ]);

    // Calculate assessment statistics
    const assessmentStats = calculateAssessmentStats(assessments);

    // Calculate overall security score
    const weights = {
      assessmentScore: 0.3,
      findingScore: 0.4,
      riskScore: 0.3
    };

    const assessmentScore = assessmentStats.averageScore;
    const findingScore = calculateFindingScore(findingMetrics);
    const riskScore = calculateRiskScore(riskStats);

    const overallScore = Math.round(
      (assessmentScore * weights.assessmentScore) +
      (findingScore * weights.findingScore) +
      (riskScore * weights.riskScore)
    );

    // Ensure trends data exists with defaults
    const findingTrends = findingMetrics.trends || {
      newFindings: { last30Days: 0, last90Days: 0 },
      closedFindings: { last30Days: 0, last90Days: 0 }
    };

    const riskTrends = riskStats.trends || {
      new: { last30Days: 0, last90Days: 0 },
      mitigated: { last30Days: 0, last90Days: 0 }
    };

    return {
      overallScore,
      summary: {
        assessments: {
          total: assessmentStats.total,
          averageScore: assessmentStats.averageScore,
          lastAssessment: assessmentStats.lastAssessment,
          trend: assessmentStats.scoreHistory
        },
        findings: {
          total: findingMetrics.total,
          open: findingMetrics.byStatus.open,
          critical: findingMetrics.bySeverity.critical + findingMetrics.bySeverity.high,
          trend: findingTrends
        },
        risks: {
          total: riskStats.total,
          active: riskStats.byStatus.active,
          critical: riskStats.byImpact.high,
          trend: riskTrends
        }
      },
      compliance: {
        accessControl: calculateControlCoverage(findings, risks, assessments, 'Access Control'),
        dataProtection: calculateControlCoverage(findings, risks, assessments, 'Data Protection'),
        vulnerabilityManagement: calculateControlCoverage(findings, risks, assessments, 'Vulnerability Management'),
        incidentResponse: calculateControlCoverage(findings, risks, assessments, 'Incident Response')
      },
      trends: {
        last30Days: {
          newFindings: findingTrends.newFindings.last30Days,
          resolvedFindings: findingTrends.closedFindings.last30Days,
          newRisks: riskTrends.new.last30Days,
          mitigatedRisks: riskTrends.mitigated.last30Days,
          assessmentsCompleted: assessmentStats.completedLast30Days
        },
        last90Days: {
          newFindings: findingTrends.newFindings.last90Days,
          resolvedFindings: findingTrends.closedFindings.last90Days,
          newRisks: riskTrends.new.last90Days,
          mitigatedRisks: riskTrends.mitigated.last90Days
        }
      },
      topRisks: risks
        .filter(r => r.status === 'active')
        .sort((a, b) => calculateRiskPriority(b) - calculateRiskPriority(a))
        .slice(0, 5),
      recentActivity: generateRecentActivity(findings, risks, assessments)
    };
  },

  // Get compliance report
  getComplianceReport: async (clientId, framework = 'general') => {
    await delay(600);
    const [findings, risks, assessments] = await Promise.all([
      auditApi.getFindings(clientId),
      riskAssessmentApi.getRisks(clientId),
      securityAssessmentsApi.getAssessments(clientId)
    ]);

    const controls = {
      'Access Control': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Access Control'),
        risks: risks.filter(r => r.category === 'Access Control'),
        assessments: getAssessmentsByCategory(assessments, 'Access Control')
      },
      'Data Protection': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Data Protection'),
        risks: risks.filter(r => r.category === 'Data Protection'),
        assessments: getAssessmentsByCategory(assessments, 'Data Protection')
      },
      'Vulnerability Management': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Vulnerability Management'),
        risks: risks.filter(r => r.category === 'Vulnerability Management'),
        assessments: getAssessmentsByCategory(assessments, 'Vulnerability Management')
      },
      'Incident Response': {
        findings: findings.filter(f => mapCategoryToControl(f.category) === 'Incident Response'),
        risks: risks.filter(r => r.category === 'Incident Response'),
        assessments: getAssessmentsByCategory(assessments, 'Incident Response')
      }
    };

    return {
      framework,
      controls: Object.entries(controls).map(([category, data]) => ({
        category,
        status: calculateControlStatus(data),
        findings: data.findings.length,
        risks: data.risks.length,
        score: calculateControlScore(data),
        gaps: identifyControlGaps(data),
        recommendations: generateControlRecommendations(data)
      }))
    };
  },

  // Get trend analysis
  getTrendAnalysis: async (clientId, period = 90) => {
    await delay(600);
    const [findings, risks, assessments] = await Promise.all([
      auditApi.getFindings(clientId),
      riskAssessmentApi.getRisks(clientId),
      securityAssessmentsApi.getAssessments(clientId)
    ]);

    const startDate = new Date();
    startDate.setDate(startDate.getDate() - period);

    const timelineData = generateTimeline(findings, risks, assessments, startDate);
    const trends = analyzeTrends(timelineData);

    return {
      period,
      timeline: timelineData,
      trends,
      projections: generateProjections(trends)
    };
  }
};

// Helper functions
const calculateAssessmentStats = (assessments) => {
  if (!Array.isArray(assessments)) {
    return {
      total: 0,
      averageScore: 0,
      lastAssessment: null,
      scoreHistory: [],
      completedLast30Days: 0
    };
  }

  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

  const completedAssessments = assessments.filter(a => a.status === 'completed');
  const sortedAssessments = [...assessments].sort((a, b) => new Date(b.date) - new Date(a.date));

  return {
    total: assessments.length,
    averageScore: calculateAverageScore(completedAssessments),
    lastAssessment: sortedAssessments[0] || null,
    scoreHistory: sortedAssessments.map(a => ({
      date: a.date,
      score: a.score || 0,
      type: a.type,
      findings: (a.generatedFindings || []).length
    })),
    completedLast30Days: completedAssessments.filter(
      a => new Date(a.date) >= thirtyDaysAgo
    ).length
  };
};

const calculateFindingScore = (metrics) => {
  const totalFindings = metrics.total;
  if (totalFindings === 0) return 100;

  const weights = {
    critical: 1,
    high: 0.8,
    medium: 0.5,
    low: 0.2
  };

  const weightedOpen = 
    (metrics.bySeverity.critical * weights.critical) +
    (metrics.bySeverity.high * weights.high) +
    (metrics.bySeverity.medium * weights.medium) +
    (metrics.bySeverity.low * weights.low);

  return Math.round(100 - (weightedOpen / totalFindings) * 100);
};

const calculateRiskScore = (stats) => {
  const totalRisks = stats.total;
  if (totalRisks === 0) return 100;

  const weights = {
    high: 1,
    medium: 0.6,
    low: 0.3
  };

  const weightedRisks = 
    (stats.byImpact.high * weights.high) +
    (stats.byImpact.medium * weights.medium) +
    (stats.byImpact.low * weights.low);

  return Math.round(100 - (weightedRisks / totalRisks) * 100);
};

const mapCategoryToControl = (category) => {
  const categoryMap = {
    'System Security': 'Vulnerability Management',
    'Data Protection': 'Data Protection',
    'Access Control': 'Access Control',
    'Audit and Accountability': 'Access Control',
    'Configuration Management': 'Vulnerability Management',
    'System and Information Integrity': 'Vulnerability Management',
    'Incident Response': 'Incident Response'
  };
  return categoryMap[category] || category;
};

const calculateControlCoverage = (findings, risks, assessments, category) => {
  const relevantFindings = findings.filter(f => 
    mapCategoryToControl(f.category) === category
  );
  const relevantRisks = risks.filter(r => r.category === category);
  const relevantAssessments = getAssessmentsByCategory(assessments, category);

  const coverage = {
    findings: {
      total: relevantFindings.length,
      open: relevantFindings.filter(f => f.status === 'open').length,
      inProgress: relevantFindings.filter(f => f.status === 'in_progress').length,
      closed: relevantFindings.filter(f => f.status === 'closed').length
    },
    risks: {
      total: relevantRisks.length,
      active: relevantRisks.filter(r => r.status === 'active').length,
      mitigated: relevantRisks.filter(r => r.status === 'mitigated').length
    },
    assessments: {
      total: relevantAssessments.length,
      averageScore: calculateAverageScore(relevantAssessments)
    }
  };

  return {
    ...coverage,
    score: calculateCoverageScore(coverage)
  };
};

const calculateRiskPriority = (risk) => {
  const impactWeights = { high: 3, medium: 2, low: 1 };
  const likelihoodWeights = { high: 3, medium: 2, low: 1 };
  return impactWeights[risk.impact] * likelihoodWeights[risk.likelihood];
};

const getAssessmentsByCategory = (assessments, category) => {
  return (assessments || []).filter(a => {
    if (!a.answers) return false;

    if (a.type === 'advanced') {
      // For advanced assessments, check specific sections
      switch (category) {
        case 'Access Control':
          return a.answers.ac1 || a.answers.ac2 || a.answers.ac3;
        case 'Data Protection':
          return a.answers.dp1 || a.answers.dp2 || a.answers.dp3;
        case 'Incident Response':
          return a.answers.ir1 || a.answers.ir2 || a.answers.ir3;
        default:
          return false;
      }
    } else {
      // For basic assessments, map question numbers to categories
      const categoryQuestions = {
        'Access Control': [3, 4, 11],
        'Data Protection': [7, 8],
        'Incident Response': [9, 10],
      };
      
      const relevantQuestions = categoryQuestions[category] || [];
      return relevantQuestions.some(q => a.answers[q] === 'yes');
    }
  });
};

const calculateAverageScore = (assessments) => {
  if (!Array.isArray(assessments) || assessments.length === 0) return 0;
  return Math.round(
    assessments.reduce((sum, a) => sum + (a.score || 0), 0) / assessments.length
  );
};

const calculateCoverageScore = (coverage) => {
  const weights = {
    findings: 0.4,
    risks: 0.3,
    assessments: 0.3
  };

  const findingScore = coverage.findings.total === 0 ? 100 :
    Math.round((coverage.findings.closed / coverage.findings.total) * 100);

  const riskScore = coverage.risks.total === 0 ? 100 :
    Math.round((coverage.risks.mitigated / coverage.risks.total) * 100);

  const assessmentScore = coverage.assessments.averageScore;

  return Math.round(
    (findingScore * weights.findings) +
    (riskScore * weights.risks) +
    (assessmentScore * weights.assessments)
  );
};

const calculateControlStatus = (data) => {
  const score = calculateControlScore(data);
  if (score >= 80) return 'effective';
  if (score >= 60) return 'needs_improvement';
  return 'ineffective';
};

const calculateControlScore = (data) => {
  const weights = {
    findings: 0.4,
    risks: 0.3,
    assessments: 0.3
  };

  const findingScore = data.findings.length === 0 ? 100 :
    100 - (data.findings.filter(f => f.status === 'open').length / data.findings.length * 100);

  const riskScore = data.risks.length === 0 ? 100 :
    100 - (data.risks.filter(r => r.status === 'active').length / data.risks.length * 100);

  const assessmentScore = data.assessments.length === 0 ? 0 :
    data.assessments.reduce((sum, a) => sum + (a.score || 0), 0) / data.assessments.length;

  return Math.round(
    (findingScore * weights.findings) +
    (riskScore * weights.risks) +
    (assessmentScore * weights.assessments)
  );
};

const identifyControlGaps = (data) => {
  const gaps = [];

  // Check for critical findings
  const criticalFindings = data.findings.filter(f => 
    f.status === 'open' && (f.severity === 'critical' || f.severity === 'high')
  );
  if (criticalFindings.length > 0) {
    gaps.push({
      type: 'critical_findings',
      count: criticalFindings.length,
      description: 'Open critical/high findings require immediate attention'
    });
  }

  // Check for active high-impact risks
  const highRisks = data.risks.filter(r => 
    r.status === 'active' && r.impact === 'high'
  );
  if (highRisks.length > 0) {
    gaps.push({
      type: 'high_risks',
      count: highRisks.length,
      description: 'Active high-impact risks need mitigation'
    });
  }

  // Check assessment scores
  const lowScoreAssessments = data.assessments.filter(a => 
    (a.score || 0) < 70
  );
  if (lowScoreAssessments.length > 0) {
    gaps.push({
      type: 'low_scores',
      count: lowScoreAssessments.length,
      description: 'Assessments indicate control weaknesses'
    });
  }

  return gaps;
};

const generateControlRecommendations = (data) => {
  const recommendations = [];

  // Analyze findings
  const openFindings = data.findings.filter(f => f.status === 'open');
  if (openFindings.length > 0) {
    const criticalCount = openFindings.filter(f => 
      f.severity === 'critical' || f.severity === 'high'
    ).length;
    
    if (criticalCount > 0) {
      recommendations.push({
        priority: 'high',
        action: 'Address critical findings',
        description: `Remediate ${criticalCount} critical/high findings`
      });
    }
  }

  // Analyze risks
  const activeRisks = data.risks.filter(r => r.status === 'active');
  if (activeRisks.length > 0) {
    const highRiskCount = activeRisks.filter(r => r.impact === 'high').length;
    
    if (highRiskCount > 0) {
      recommendations.push({
        priority: 'high',
        action: 'Mitigate high-impact risks',
        description: `Implement controls for ${highRiskCount} high-impact risks`
      });
    }
  }

  // Analyze assessments
  const recentAssessments = data.assessments
    .sort((a, b) => new Date(b.date) - new Date(a.date))
    .slice(0, 3);

  const averageScore = calculateAverageScore(recentAssessments);
  if (averageScore < 70) {
    recommendations.push({
      priority: 'medium',
      action: 'Improve control effectiveness',
      description: 'Recent assessments indicate need for control improvements'
    });
  }

  return recommendations;
};

const generateTimeline = (findings, risks, assessments, startDate) => {
  const timeline = [];
  const endDate = new Date();

  // Generate daily data points
  for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const date = d.toISOString().split('T')[0];
    
    const dayFindings = findings.filter(f => 
      f.createdDate.split('T')[0] === date
    );
    
    const dayRisks = risks.filter(r => 
      r.lastAssessed.split('T')[0] === date
    );
    
    const dayAssessments = assessments.filter(a => 
      a.date.split('T')[0] === date
    );

    if (dayFindings.length > 0 || dayRisks.length > 0 || dayAssessments.length > 0) {
      timeline.push({
        date,
        findings: {
          new: dayFindings.length,
          closed: dayFindings.filter(f => f.status === 'closed').length
        },
        risks: {
          new: dayRisks.length,
          mitigated: dayRisks.filter(r => r.status === 'mitigated').length
        },
        assessments: {
          completed: dayAssessments.filter(a => a.status === 'completed').length,
          averageScore: calculateAverageScore(dayAssessments)
        }
      });
    }
  }

  return timeline;
};

const analyzeTrends = (timeline) => {
  const findingsTrend = calculateTrendLine(timeline.map(t => ({
    x: new Date(t.date).getTime(),
    y: t.findings.new - t.findings.closed
  })));

  const risksTrend = calculateTrendLine(timeline.map(t => ({
    x: new Date(t.date).getTime(),
    y: t.risks.new - t.risks.mitigated
  })));

  const assessmentsTrend = calculateTrendLine(timeline.map(t => ({
    x: new Date(t.date).getTime(),
    y: t.assessments.averageScore
  })));

  return {
    findings: findingsTrend,
    risks: risksTrend,
    assessments: assessmentsTrend
  };
};

const calculateTrendLine = (points) => {
  if (points.length < 2) return { slope: 0, direction: 'stable' };

  let sumX = 0;
  let sumY = 0;
  let sumXY = 0;
  let sumXX = 0;
  
  points.forEach(point => {
    sumX += point.x;
    sumY += point.y;
    sumXY += point.x * point.y;
    sumXX += point.x * point.x;
  });

  const n = points.length;
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);

  return {
    slope,
    direction: slope > 0.1 ? 'increasing' : slope < -0.1 ? 'decreasing' : 'stable'
  };
};

const generateProjections = (trends) => {
  return {
    findings: {
      direction: trends.findings.direction,
      impact: trends.findings.slope > 0.5 ? 'high' : 
        trends.findings.slope > 0.2 ? 'medium' : 'low'
    },
    risks: {
      direction: trends.risks.direction,
      impact: trends.risks.slope > 0.5 ? 'high' : 
        trends.risks.slope > 0.2 ? 'medium' : 'low'
    },
    assessments: {
      direction: trends.assessments.direction,
      impact: Math.abs(trends.assessments.slope) > 5 ? 'high' : 
        Math.abs(trends.assessments.slope) > 2 ? 'medium' : 'low'
    }
  };
};

const generateRecentActivity = (findings, risks, assessments) => {
  if (!Array.isArray(findings)) findings = [];
  if (!Array.isArray(risks)) risks = [];
  if (!Array.isArray(assessments)) assessments = [];

  const activities = [
    ...findings.map(f => ({
      type: 'finding',
      date: f.createdDate,
      title: f.title,
      severity: f.severity,
      status: f.status
    })),
    ...risks.map(r => ({
      type: 'risk',
      date: r.lastAssessed,
      title: r.name,
      severity: r.impact,
      status: r.status
    })),
    ...assessments.map(a => ({
      type: 'assessment',
      date: a.date,
      title: a.name,
      score: a.score,
      status: a.status
    }))
  ];

  return activities
    .sort((a, b) => new Date(b.date) - new Date(a.date))
    .slice(0, 10);
};

export default reportingApi;

================
File: client/RiskAssessmentApi.js
================
// src/services/api/client/RiskAssessmentApi.js
import { BaseApiService } from '../BaseApiService';
import { validateRequired, get } from '../../utils/apiHelpers';
import { IS_MOCK } from '../../config';

class RiskAssessmentApi extends BaseApiService {
  constructor() {
    super('/risks', 'riskAssessment');
  }

  // Get all risks for a client
  async getRisks(clientId, options = {}) {
    validateRequired({ clientId }, ['clientId']);
    return this.getAll({ clientId: Number(clientId), ...options });
  }

  // Get single risk
  async getRisk(clientId, riskId) {
    validateRequired({ clientId, riskId }, ['clientId', 'riskId']);
    return this.getById(riskId);
  }

  // Create new risk
  async createRisk(clientId, riskData) {
    validateRequired({ clientId }, ['clientId']);
    validateRequired(riskData, ['name', 'description', 'impact', 'likelihood']);
    
    return this.create({
      clientId: Number(clientId),
      ...riskData,
      status: riskData.status || 'open',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });
  }

  // Update risk
  async updateRisk(clientId, riskId, updates) {
    validateRequired({ clientId, riskId }, ['clientId', 'riskId']);
    
    return this.partialUpdate(riskId, {
      clientId: Number(clientId),
      ...updates,
      updatedAt: new Date().toISOString()
    });
  }

  // Delete risk
  async deleteRisk(clientId, riskId) {
    validateRequired({ clientId, riskId }, ['clientId', 'riskId']);
    return this.delete(riskId);
  }

  // Get risk levels
  async getRiskLevels() {
    if (IS_MOCK) {
      return ['Critical', 'High', 'Medium', 'Low', 'Negligible'];
    }
    return get(`${this.baseUrl}${this.basePath}/risk-levels`);
  }

  // Get risk statuses
  async getRiskStatuses() {
    if (IS_MOCK) {
      return ['Open', 'Mitigated', 'Accepted', 'Transferred', 'Closed'];
    }
    return get(`${this.baseUrl}${this.basePath}/risk-statuses`);
  }

  // Get risk statistics for a client
  async getRiskStats(clientId) {
    validateRequired({ clientId }, ['clientId']);
    
    if (IS_MOCK) {
      // Generate mock risk statistics
      return {
        total: 12,
        byStatus: {
          'Open': 5,
          'Mitigated': 3,
          'Accepted': 2,
          'Transferred': 1,
          'Closed': 1
        },
        byLevel: {
          'Critical': 2,
          'High': 3,
          'Medium': 4,
          'Low': 2,
          'Negligible': 1
        },
        trend: [
          { month: 'Jan', count: 8 },
          { month: 'Feb', count: 10 },
          { month: 'Mar', count: 12 },
          { month: 'Apr', count: 11 },
          { month: 'May', count: 12 }
        ]
      };
    }
    
    return get(`${this.baseUrl}${this.basePath}/stats?clientId=${Number(clientId)}`);
  }

  // Get framework compliance progress
  async getFrameworkProgress(clientId) {
    validateRequired({ clientId }, ['clientId']);
    
    if (IS_MOCK) {
      // Generate mock framework progress data
      return {
        nist: {
          name: 'NIST CSF',
          progress: 68,
          categories: [
            { name: 'Identify', progress: 75 },
            { name: 'Protect', progress: 82 },
            { name: 'Detect', progress: 60 },
            { name: 'Respond', progress: 55 },
            { name: 'Recover', progress: 45 }
          ]
        },
        iso27001: {
          name: 'ISO 27001',
          progress: 72,
          categories: [
            { name: 'Security Policy', progress: 90 },
            { name: 'Organization of Information Security', progress: 85 },
            { name: 'Asset Management', progress: 70 },
            { name: 'Human Resources Security', progress: 65 },
            { name: 'Physical Security', progress: 80 },
            { name: 'Communications Security', progress: 60 },
            { name: 'Access Control', progress: 75 }
          ]
        }
      };
    }
    
    return get(`${this.baseUrl}${this.basePath}/framework-progress?clientId=${Number(clientId)}`);
  }

  // Get risk-objective mappings
  async getRiskObjectiveMappings(clientId) {
    validateRequired({ clientId }, ['clientId']);
    
    if (IS_MOCK) {
      // Generate mock risk-objective mappings
      return [
        { id: 'rom-1', riskId: 'risk-1', objectiveId: 'obj-1', relationship: 'mitigates' },
        { id: 'rom-2', riskId: 'risk-2', objectiveId: 'obj-2', relationship: 'mitigates' },
        { id: 'rom-3', riskId: 'risk-3', objectiveId: 'obj-3', relationship: 'mitigates' }
      ];
    }
    
    return get(`${this.baseUrl}${this.basePath}/risk-objective-mappings?clientId=${Number(clientId)}`);
  }

  // Create risk-objective mapping
  async createRiskObjectiveMapping(clientId, riskId, objectiveId) {
    validateRequired({ clientId, riskId, objectiveId }, ['clientId', 'riskId', 'objectiveId']);
    
    if (IS_MOCK) {
      return {
        id: `rom-${Date.now()}`,
        riskId,
        objectiveId,
        relationship: 'mitigates',
        createdAt: new Date().toISOString()
      };
    }
    
    return this.create({
      clientId: Number(clientId),
      riskId,
      objectiveId,
      relationship: 'mitigates',
      createdAt: new Date().toISOString()
    }, '/risk-objective-mappings');
  }

  // Get objective-initiative mappings
  async getObjectiveInitiativeMappings(clientId) {
    validateRequired({ clientId }, ['clientId']);
    
    if (IS_MOCK) {
      // Generate mock objective-initiative mappings
      return [
        { id: 'oim-1', objectiveId: 'obj-1', initiativeId: 'init-1' },
        { id: 'oim-2', objectiveId: 'obj-2', initiativeId: 'init-2' },
        { id: 'oim-3', objectiveId: 'obj-3', initiativeId: 'init-3' }
      ];
    }
    
    return get(`${this.baseUrl}${this.basePath}/objective-initiative-mappings?clientId=${Number(clientId)}`);
  }

  // Create objective-initiative mapping
  async createObjectiveInitiativeMapping(clientId, objectiveId, initiativeId) {
    validateRequired({ clientId, objectiveId, initiativeId }, ['clientId', 'objectiveId', 'initiativeId']);
    
    if (IS_MOCK) {
      return {
        id: `oim-${Date.now()}`,
        objectiveId,
        initiativeId,
        createdAt: new Date().toISOString()
      };
    }
    
    return this.create({
      clientId: Number(clientId),
      objectiveId,
      initiativeId,
      createdAt: new Date().toISOString()
    }, '/objective-initiative-mappings');
  }

  // Delete objective-initiative mapping
  async deleteObjectiveInitiativeMapping(clientId, objectiveId, initiativeId) {
    validateRequired({ clientId, objectiveId, initiativeId }, ['clientId', 'objectiveId', 'initiativeId']);
    
    if (IS_MOCK) {
      return { success: true };
    }
    
    return this.delete(`mapping/${objectiveId}/${initiativeId}`);
  }

  // Calculate risk score
  calculateRiskScore(impact, likelihood) {
    const impactMap = {
      'Critical': 5,
      'High': 4,
      'Medium': 3,
      'Low': 2,
      'Negligible': 1
    };
    
    const likelihoodMap = {
      'Critical': 5,
      'High': 4,
      'Medium': 3,
      'Low': 2,
      'Negligible': 1
    };
    
    const impactScore = impactMap[impact] || 1;
    const likelihoodScore = likelihoodMap[likelihood] || 1;
    
    return impactScore * likelihoodScore;
  }
}

export default new RiskAssessmentApi();

================
File: client/SecurityAssessmentsApi.js
================
import { validateRequired } from '../../apiHelpers';
import riskAssessmentApi from '../../api/client/RiskAssessmentApi';
import securityObjectivesApi from '../../api/client/SecurityObjectivesApi';

const API_URL = 'http://localhost:3001';

const securityAssessmentsApi = {
  // Get all assessments for a client
  getAssessments: async (clientId, options = {}) => {
    validateRequired({ clientId }, ['clientId']);
    
    try {
      const response = await fetch(`${API_URL}/assessments?clientId=${clientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch assessments');
      }
      let assessments = await response.json();

      // Apply filters
      if (options.status && options.status !== 'all') {
        assessments = assessments.filter(a => a.status === options.status);
      }
      if (options.type && options.type !== 'all') {
        assessments = assessments.filter(a => a.type === options.type);
      }
      if (options.dateRange) {
        const { start, end } = options.dateRange;
        assessments = assessments.filter(a => {
          const assessmentDate = new Date(a.date);
          return assessmentDate >= new Date(start) && assessmentDate <= new Date(end);
        });
      }

      // Apply sorting
      if (options.sortBy) {
        assessments.sort((a, b) => {
          switch (options.sortBy) {
            case 'date':
              return new Date(b.date) - new Date(a.date);
            case 'score':
              return (b.score || 0) - (a.score || 0);
            default:
              return 0;
          }
        });
      }

      return assessments;
    } catch (error) {
      console.error('Error fetching assessments:', error);
      return [];
    }
  },

  // Get assessment by ID
  getAssessment: async (assessmentId) => {
    validateRequired({ assessmentId }, ['assessmentId']);
    
    try {
      const response = await fetch(`${API_URL}/assessments/${assessmentId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch assessment');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching assessment:', error);
      throw error;
    }
  },

  // Get findings for an assessment
  getFindings: async (assessmentId) => {
    validateRequired({ assessmentId }, ['assessmentId']);
    
    try {
      const response = await fetch(`${API_URL}/assessments/${assessmentId}/generatedFindings`);
      if (!response.ok) {
        throw new Error('Failed to fetch findings');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching findings:', error);
      return [];
    }
  },

  // Get risks promoted from findings
  getPromotedRisks: async (clientId) => {
    validateRequired({ clientId }, ['clientId']);
    
    try {
      // Get risks from the risk assessment API
      const risks = await riskAssessmentApi.getRisks(clientId);
      
      // Filter risks that were promoted from findings
      const promotedRisks = risks.filter(risk => risk.sourceFindings && risk.sourceFindings.length > 0);
      
      return promotedRisks;
    } catch (error) {
      console.error('Error fetching promoted risks:', error);
      return [];
    }
  },

  // Promote finding to risk
  promoteFindingToRisk: async (clientId, findingId, riskData) => {
    validateRequired({ clientId, findingId }, ['clientId', 'findingId']);
    validateRequired(riskData, ['name', 'description', 'impact', 'likelihood', 'category']);
    
    try {
      // First get the finding details
      const findingResponse = await fetch(`${API_URL}/assessments/${findingId}`);
      if (!findingResponse.ok) {
        throw new Error('Finding not found');
      }
      
      const finding = await findingResponse.json();
      
      // Create a new risk with the finding as the source
      const newRisk = await riskAssessmentApi.createRisk(clientId, {
        ...riskData,
        sourceFindings: [{
          findingId: finding.id,
          title: finding.title || finding.name,
          sourceType: finding.sourceType || 'security_assessment',
          date: new Date().toISOString()
        }]
      });
      
      // Update the finding status to promoted
      await fetch(`${API_URL}/assessments/${findingId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status: 'promoted_to_risk',
          promotedRiskId: newRisk.id,
          lastUpdated: new Date().toISOString()
        })
      });
      
      return newRisk;
    } catch (error) {
      console.error('Error promoting finding to risk:', error);
      throw error;
    }
  },

  // Promote risk to objective
  promoteRiskToObjective: async (clientId, riskId, objectiveData = {}) => {
    validateRequired({ clientId, riskId }, ['clientId', 'riskId']);
    
    try {
      // Get the risk details
      const risk = await riskAssessmentApi.getRisk(clientId, riskId);
      
      // Create default objective data based on the risk
      const defaultObjectiveData = {
        name: `Address Risk: ${risk.name}`,
        description: risk.description,
        priority: risk.impact === 'high' ? 'High' : 'Medium',
        status: 'Planning',
        dueDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),
        sourceRisk: risk.id,
        riskId: risk.id,
        treatmentApproach: risk.treatment?.approach || 'mitigate'
      };
      
      // Merge with any provided objective data
      const mergedObjectiveData = {
        ...defaultObjectiveData,
        ...objectiveData
      };
      
      // Create the objective
      const objective = await securityObjectivesApi.createObjective(clientId, mergedObjectiveData);
      
      // Link the objective to the risk
      await riskAssessmentApi.linkObjectiveToRisk(clientId, riskId, objective.id);
      
      return objective;
    } catch (error) {
      console.error('Error promoting risk to objective:', error);
      throw error;
    }
  },

  // Submit a new assessment
  submitAssessment: async (clientId, assessmentData) => {
    validateRequired(assessmentData, ['type', 'name', 'answers']);
    validateRequired({ clientId }, ['clientId']);
    
    try {
      const response = await fetch(`${API_URL}/assessments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          clientId: Number(clientId),
          date: new Date().toISOString(),
          status: 'pending_review',
          ...assessmentData
        })
      });

      if (!response.ok) {
        throw new Error('Failed to submit assessment');
      }

      return await response.json();
    } catch (error) {
      console.error('Error submitting assessment:', error);
      throw error;
    }
  },

  // Update assessment status
  updateAssessmentStatus: async (assessmentId, status) => {
    validateRequired({ assessmentId, status }, ['assessmentId', 'status']);
    
    try {
      const response = await fetch(`${API_URL}/assessments/${assessmentId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status,
          lastUpdated: new Date().toISOString()
        })
      });

      if (!response.ok) {
        throw new Error('Failed to update assessment status');
      }

      return await response.json();
    } catch (error) {
      console.error('Error updating assessment status:', error);
      throw error;
    }
  },

  // Review assessment
  reviewAssessment: async (assessmentId, reviewData) => {
    validateRequired(reviewData, ['reviewer', 'status']);
    validateRequired({ assessmentId }, ['assessmentId']);
    
    try {
      const response = await fetch(`${API_URL}/assessments/${assessmentId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          reviewer: reviewData.reviewer,
          status: reviewData.status,
          reviewNotes: reviewData.notes,
          reviewDate: new Date().toISOString()
        })
      });

      if (!response.ok) {
        throw new Error('Failed to review assessment');
      }

      return await response.json();
    } catch (error) {
      console.error('Error reviewing assessment:', error);
      throw error;
    }
  },

  // Get assessment statistics
  getAssessmentStats: async (clientId) => {
    validateRequired({ clientId }, ['clientId']);
    
    try {
      const assessments = await securityAssessmentsApi.getAssessments(clientId);
      
      return {
        total: assessments.length,
        byStatus: {
          pending: assessments.filter(a => a.status === 'pending_review').length,
          inProgress: assessments.filter(a => a.status === 'in_progress').length,
          completed: assessments.filter(a => a.status === 'completed').length,
          promoted: assessments.filter(a => a.status === 'promoted_to_risk').length
        },
        byType: {
          basic: assessments.filter(a => a.type === 'basic').length,
          advanced: assessments.filter(a => a.type === 'advanced').length,
          custom: assessments.filter(a => a.type === 'custom').length
        },
        recent: assessments
          .sort((a, b) => new Date(b.date) - new Date(a.date))
          .slice(0, 5)
      };
    } catch (error) {
      console.error('Error getting assessment stats:', error);
      return {
        total: 0,
        byStatus: { pending: 0, inProgress: 0, completed: 0, promoted: 0 },
        byType: { basic: 0, advanced: 0, custom: 0 },
        recent: []
      };
    }
  }
};

export default securityAssessmentsApi;

================
File: client/SecurityInitiativesApi.js
================
/* eslint-disable no-unused-vars */
import { validateRequired, checkExists } from '../../apiHelpers';
import riskAssessmentApi from '../../api/client/RiskAssessmentApi';

const API_URL = 'http://localhost:3001';

const INITIATIVE_STATUS = ['Planning', 'In Progress', 'Completed', 'On Hold', 'Cancelled'];
const PHASES = ['Assessment', 'Design', 'Implementation', 'Testing', 'Deployment', 'Review'];

const securityInitiativesApi = {
  // Get all initiatives for a client
  getInitiatives: async (clientId) => {
    validateRequired({ clientId }, ['clientId']);
    const numericClientId = Number(clientId);

    try {
      const response = await fetch(`${API_URL}/security-initiatives?clientId=${numericClientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch initiatives');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching initiatives:', error);
      return [];
    }
  },

  // Get initiatives by objective
  getInitiativesByObjective: async (clientId, objectiveId) => {
    validateRequired({ clientId, objectiveId }, ['clientId', 'objectiveId']);
    const numericClientId = Number(clientId);

    try {
      // For risk-based objectives, also fetch risk details
      if (objectiveId.startsWith('risk-')) {
        const riskId = objectiveId.split('-')[1];
        const risk = await riskAssessmentApi.getRisk(clientId, riskId);
        if (!risk) {
          throw new Error('Related risk not found');
        }
      }

      const response = await fetch(`${API_URL}/security-initiatives?clientId=${numericClientId}&objectiveId=${objectiveId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch initiatives');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching initiatives by objective:', error);
      return [];
    }
  },

  // Get single initiative
  getInitiative: async (clientId, initiativeId) => {
    validateRequired({ clientId, initiativeId }, ['clientId', 'initiativeId']);
    const numericClientId = Number(clientId);

    try {
      const response = await fetch(`${API_URL}/security-initiatives/${initiativeId}?clientId=${numericClientId}`);
      if (!response.ok) {
        throw new Error('Initiative not found');
      }
      const initiative = await response.json();

      // If this initiative is linked to a risk-based objective, include risk info
      if (initiative.objectiveId && initiative.objectiveId.startsWith('risk-')) {
        const riskId = initiative.objectiveId.split('-')[1];
        const risk = await riskAssessmentApi.getRisk(clientId, riskId);
        if (risk) {
          return {
            ...initiative,
            riskInfo: {
              name: risk.name,
              impact: risk.impact,
              likelihood: risk.likelihood,
              status: risk.status
            }
          };
        }
      }

      return initiative;
    } catch (error) {
      console.error('Error fetching initiative:', error);
      throw error;
    }
  },

  // Create new initiative
  createInitiative: async (clientId, initiativeData) => {
    validateRequired(initiativeData, ['name', 'phase', 'timeline', 'objectiveId']);
    validateRequired({ clientId }, ['clientId']);

    if (!PHASES.includes(initiativeData.phase)) {
      throw new Error('Invalid phase');
    }

    if (!initiativeData.status) {
      initiativeData.status = 'Planning';
    } else if (!INITIATIVE_STATUS.includes(initiativeData.status)) {
      throw new Error('Invalid status');
    }

    try {
      // If this is for a risk-based objective, validate the risk exists
      if (initiativeData.objectiveId.startsWith('risk-')) {
        const riskId = initiativeData.objectiveId.split('-')[1];
        const risk = await riskAssessmentApi.getRisk(clientId, riskId);
        if (!risk) {
          throw new Error('Related risk not found');
        }
      }

      const response = await fetch(`${API_URL}/security-initiatives`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId: Number(clientId),
          ...initiativeData,
          milestones: initiativeData.milestones || [],
          resources: initiativeData.resources || {
            team: [],
            budget: '0',
            tools: []
          }
        })
      });

      if (!response.ok) {
        throw new Error('Failed to create initiative');
      }

      const newInitiative = await response.json();

      // Create the objective-initiative mapping
      await riskAssessmentApi.createObjectiveInitiativeMapping(
        clientId, 
        initiativeData.objectiveId, 
        newInitiative.id
      );

      return newInitiative;
    } catch (error) {
      console.error('Error creating initiative:', error);
      throw error;
    }
  },

  // Update initiative
  updateInitiative: async (clientId, initiativeId, updates) => {
    validateRequired({ clientId, initiativeId }, ['clientId', 'initiativeId']);
    const numericClientId = Number(clientId);

    try {
      const initiative = await securityInitiativesApi.getInitiative(clientId, initiativeId);

      if (updates.phase && !PHASES.includes(updates.phase)) {
        throw new Error('Invalid phase');
      }

      if (updates.status && !INITIATIVE_STATUS.includes(updates.status)) {
        throw new Error('Invalid status');
      }

      // If this initiative is linked to a risk-based objective
      if (initiative.objectiveId && initiative.objectiveId.startsWith('risk-')) {
        const riskId = initiative.objectiveId.split('-')[1];
        
        // If initiative is completed, update risk status
        if (updates.status === 'Completed') {
          await riskAssessmentApi.updateRisk(clientId, riskId, {
            mitigationStatus: 'implemented'
          });
        }
      }

      // If the objectiveId has changed, update the mapping
      if (updates.objectiveId && initiative.objectiveId !== updates.objectiveId) {
        // Delete old mapping
        await riskAssessmentApi.deleteObjectiveInitiativeMapping(
          clientId, 
          initiative.objectiveId, 
          initiativeId
        );
        
        // Create new mapping
        await riskAssessmentApi.createObjectiveInitiativeMapping(
          clientId, 
          updates.objectiveId, 
          initiativeId
        );
      }

      const response = await fetch(`${API_URL}/security-initiatives/${initiativeId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId: numericClientId,
          ...updates
        })
      });

      if (!response.ok) {
        throw new Error('Failed to update initiative');
      }

      return await response.json();
    } catch (error) {
      console.error('Error updating initiative:', error);
      throw error;
    }
  },

  // Delete initiative
  deleteInitiative: async (clientId, initiativeId) => {
    validateRequired({ clientId, initiativeId }, ['clientId', 'initiativeId']);

    try {
      // Get the initiative to find its objectiveId
      const initiative = await securityInitiativesApi.getInitiative(clientId, initiativeId);
      
      const response = await fetch(`${API_URL}/security-initiatives/${initiativeId}?clientId=${clientId}`, {
        method: 'DELETE'
      });

      if (!response.ok) {
        throw new Error('Failed to delete initiative');
      }

      // Delete the objective-initiative mapping if it exists
      if (initiative && initiative.objectiveId) {
        await riskAssessmentApi.deleteObjectiveInitiativeMapping(
          clientId, 
          initiative.objectiveId, 
          initiativeId
        );
      }

      return { success: true, message: 'Security initiative deleted successfully' };
    } catch (error) {
      console.error('Error deleting initiative:', error);
      throw error;
    }
  },

  // Add milestone
  addMilestone: async (clientId, initiativeId, milestoneData) => {
    validateRequired({ clientId, initiativeId }, ['clientId', 'initiativeId']);
    validateRequired(milestoneData, ['name']);

    try {
      const response = await fetch(`${API_URL}/security-initiatives/${initiativeId}/milestones`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId: Number(clientId),
          ...milestoneData,
          completed: milestoneData.completed || false
        })
      });

      if (!response.ok) {
        throw new Error('Failed to add milestone');
      }

      const result = await response.json();

      // If all milestones are completed, update initiative status
      const initiative = await securityInitiativesApi.getInitiative(clientId, initiativeId);
      const allCompleted = initiative.milestones.every(m => m.completed);
      if (allCompleted) {
        await securityInitiativesApi.updateInitiative(clientId, initiativeId, { status: 'Completed' });
      }

      return result;
    } catch (error) {
      console.error('Error adding milestone:', error);
      throw error;
    }
  },

  // Update milestone
  updateMilestone: async (clientId, initiativeId, milestoneId, updates) => {
    validateRequired({ clientId, initiativeId, milestoneId }, ['clientId', 'initiativeId', 'milestoneId']);

    try {
      const response = await fetch(`${API_URL}/security-initiatives/${initiativeId}/milestones/${milestoneId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId: Number(clientId),
          ...updates
        })
      });

      if (!response.ok) {
        throw new Error('Failed to update milestone');
      }

      const result = await response.json();

      // If all milestones are completed, update initiative status
      const initiative = await securityInitiativesApi.getInitiative(clientId, initiativeId);
      const allCompleted = initiative.milestones.every(m => m.completed);
      if (allCompleted) {
        await securityInitiativesApi.updateInitiative(clientId, initiativeId, { status: 'Completed' });
      }

      return result;
    } catch (error) {
      console.error('Error updating milestone:', error);
      throw error;
    }
  },

  // Delete milestone
  deleteMilestone: async (clientId, initiativeId, milestoneId) => {
    validateRequired({ clientId, initiativeId, milestoneId }, ['clientId', 'initiativeId', 'milestoneId']);

    try {
      const response = await fetch(`${API_URL}/security-initiatives/${initiativeId}/milestones/${milestoneId}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId: Number(clientId)
        })
      });

      if (!response.ok) {
        throw new Error('Failed to delete milestone');
      }

      return { success: true, message: 'Milestone deleted successfully' };
    } catch (error) {
      console.error('Error deleting milestone:', error);
      throw error;
    }
  },

  // Update resources
  updateResources: async (clientId, initiativeId, resources) => {
    validateRequired({ clientId, initiativeId }, ['clientId', 'initiativeId']);
    validateRequired(resources, ['team', 'budget', 'tools']);

    try {
      const response = await fetch(`${API_URL}/security-initiatives/${initiativeId}/resources`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId: Number(clientId),
          resources
        })
      });

      if (!response.ok) {
        throw new Error('Failed to update resources');
      }

      return await response.json();
    } catch (error) {
      console.error('Error updating resources:', error);
      throw error;
    }
  },

  // Get initiative statuses
  getInitiativeStatuses: async () => {
    return [...INITIATIVE_STATUS];
  },

  // Get phases
  getPhases: async () => {
    return [...PHASES];
  },

  // Promote objective to initiative
  promoteObjectiveToInitiative: async (clientId, objectiveId, initiativeData = {}) => {
    validateRequired({ clientId, objectiveId }, ['clientId', 'objectiveId']);
    
    try {
      // Create default initiative data based on the objective
      const defaultInitiativeData = {
        name: `Initiative for Objective: ${objectiveId}`,
        description: 'Implementation initiative for security objective',
        phase: 'Planning',
        timeline: `Q${Math.floor(Math.random() * 4) + 1} ${new Date().getFullYear()}`,
        status: 'Planning',
        objectiveId: objectiveId,
        milestones: [
          {
            name: 'Planning Phase Complete',
            completed: false,
            dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
          },
          {
            name: 'Implementation Started',
            completed: false,
            dueDate: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000).toISOString()
          }
        ],
        resources: {
          team: ['Security Team'],
          budget: '$0',
          tools: []
        }
      };
      
      // Merge with any provided initiative data
      const mergedInitiativeData = {
        ...defaultInitiativeData,
        ...initiativeData
      };
      
      // Create the initiative
      const initiative = await securityInitiativesApi.createInitiative(clientId, mergedInitiativeData);
      
      return initiative;
    } catch (error) {
      console.error('Error promoting objective to initiative:', error);
      throw error;
    }
  }
};

export default securityInitiativesApi;

================
File: client/SecurityObjectivesApi.js
================
// src/services/api/client/SecurityObjectivesApi.js
import { BaseApiService } from '../BaseApiService';
import { validateRequired, get } from '../../utils/apiHelpers';
import { IS_MOCK } from '../../config';

class SecurityObjectivesApi extends BaseApiService {
  constructor() {
    super('/security-objectives', 'securityObjectives');
  }

  // Get all objectives for a client
  async getObjectives(clientId, options = {}) {
    validateRequired({ clientId }, ['clientId']);
    return this.getAll({ clientId: Number(clientId), ...options });
  }

  // Get single objective
  async getObjective(clientId, objectiveId) {
    validateRequired({ clientId, objectiveId }, ['clientId', 'objectiveId']);
    return this.getById(objectiveId);
  }

  // Create new objective
  async createObjective(clientId, objectiveData) {
    validateRequired({ clientId }, ['clientId']);
    validateRequired(objectiveData, ['name', 'priority', 'dueDate']);
    
    return this.create({
      clientId: Number(clientId),
      ...objectiveData,
      status: objectiveData.status || 'Planning',
      progress: objectiveData.progress || 0,
      metrics: objectiveData.metrics || {
        successCriteria: [],
        currentMetrics: []
      }
    });
  }

  // Update objective
  async updateObjective(clientId, objectiveId, updates) {
    validateRequired({ clientId, objectiveId }, ['clientId', 'objectiveId']);
    
    return this.partialUpdate(objectiveId, {
      clientId: Number(clientId),
      ...updates
    });
  }

  // Delete objective
  async deleteObjective(clientId, objectiveId) {
    validateRequired({ clientId, objectiveId }, ['clientId', 'objectiveId']);
    
    // Special case for risk-based objectives
    if (objectiveId.startsWith('risk-')) {
      throw new Error('Cannot delete risk-based objectives directly. Address the underlying risk instead.');
    }
    
    return this.delete(objectiveId);
  }

  // Update objective metrics
  async updateObjectiveMetrics(clientId, objectiveId, metrics) {
    validateRequired({ clientId, objectiveId }, ['clientId', 'objectiveId']);
    validateRequired(metrics, ['successCriteria', 'currentMetrics']);
    
    return this.partialUpdate(objectiveId, {
      metrics
    });
  }

  // Get objective statuses
  async getObjectiveStatuses() {
    if (IS_MOCK) {
      return ['Planning', 'In Progress', 'Completed', 'On Hold', 'Cancelled'];
    }
    return get(`${this.baseUrl}${this.basePath}/statuses`);
  }

  // Get priority levels
  async getPriorityLevels() {
    if (IS_MOCK) {
      return ['High', 'Medium', 'Low'];
    }
    return get(`${this.baseUrl}${this.basePath}/priority-levels`);
  }
}

export default new SecurityObjectivesApi();

================
File: client/SecurityStrategyApi.js
================
import { validateRequired } from '../../apiHelpers';

const API_URL = 'http://localhost:3001';

const securityStrategyApi = {
  // Get security strategy for a client
  getSecurityStrategy: async (clientId) => {
    validateRequired({ clientId }, ['clientId']);
    
    try {
      const response = await fetch(`${API_URL}/securityStrategy?clientId=${clientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch security strategy');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching security strategy:', error);
      return {
        objectives: [],
        roadmap: [],
        policies: []
      };
    }
  },
  
  // Get security objectives
  getSecurityObjectives: async (clientId) => {
    validateRequired({ clientId }, ['clientId']);
    
    try {
      const response = await fetch(`${API_URL}/securityObjectives?clientId=${clientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch security objectives');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching security objectives:', error);
      return [];
    }
  },
  
  // Get security roadmap
  getSecurityRoadmap: async (clientId) => {
    validateRequired({ clientId }, ['clientId']);
    
    try {
      const response = await fetch(`${API_URL}/securityRoadmap?clientId=${clientId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch security roadmap');
      }
      return await response.json();
    } catch (error) {
      console.error('Error fetching security roadmap:', error);
      return [];
    }
  },
  
  // Update security strategy
  updateSecurityStrategy: async (clientId, strategyData) => {
    validateRequired({ clientId }, ['clientId']);
    validateRequired(strategyData, ['name', 'description']);
    
    try {
      const response = await fetch(`${API_URL}/securityStrategy/${clientId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(strategyData)
      });
      
      if (!response.ok) {
        throw new Error('Failed to update security strategy');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error updating security strategy:', error);
      throw error;
    }
  },
  
  // Create security objective
  createSecurityObjective: async (clientId, objectiveData) => {
    validateRequired({ clientId }, ['clientId']);
    validateRequired(objectiveData, ['name', 'description', 'priority']);
    
    try {
      const response = await fetch(`${API_URL}/securityObjectives`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          clientId: Number(clientId),
          ...objectiveData,
          createdAt: new Date().toISOString(),
          status: objectiveData.status || 'Planning'
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to create security objective');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error creating security objective:', error);
      throw error;
    }
  },
  
  // Update security objective
  updateSecurityObjective: async (clientId, objectiveId, objectiveData) => {
    validateRequired({ clientId, objectiveId }, ['clientId', 'objectiveId']);
    
    try {
      const response = await fetch(`${API_URL}/securityObjectives/${objectiveId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...objectiveData,
          updatedAt: new Date().toISOString()
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to update security objective');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error updating security objective:', error);
      throw error;
    }
  },
  
  // Delete security objective
  deleteSecurityObjective: async (objectiveId) => {
    validateRequired({ objectiveId }, ['objectiveId']);
    
    try {
      const response = await fetch(`${API_URL}/securityObjectives/${objectiveId}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error('Failed to delete security objective');
      }
      
      return true;
    } catch (error) {
      console.error('Error deleting security objective:', error);
      throw error;
    }
  },
  
  // Add roadmap item
  addRoadmapItem: async (clientId, roadmapData) => {
    validateRequired({ clientId }, ['clientId']);
    validateRequired(roadmapData, ['title', 'description', 'timeline']);
    
    try {
      const response = await fetch(`${API_URL}/securityRoadmap`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          clientId: Number(clientId),
          ...roadmapData,
          createdAt: new Date().toISOString(),
          status: roadmapData.status || 'Planned'
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to add roadmap item');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error adding roadmap item:', error);
      throw error;
    }
  },
  
  // Update roadmap item
  updateRoadmapItem: async (clientId, itemId, itemData) => {
    validateRequired({ clientId, itemId }, ['clientId', 'itemId']);
    
    try {
      const response = await fetch(`${API_URL}/securityRoadmap/${itemId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...itemData,
          updatedAt: new Date().toISOString()
        })
      });
      
      if (!response.ok) {
        throw new Error('Failed to update roadmap item');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error updating roadmap item:', error);
      throw error;
    }
  },
  
  // Delete roadmap item
  deleteRoadmapItem: async (itemId) => {
    validateRequired({ itemId }, ['itemId']);
    
    try {
      const response = await fetch(`${API_URL}/securityRoadmap/${itemId}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error('Failed to delete roadmap item');
      }
      
      return true;
    } catch (error) {
      console.error('Error deleting roadmap item:', error);
      throw error;
    }
  }
};

export default securityStrategyApi;

================
File: grc/AuthApi.js
================
/* eslint-disable no-unused-vars */
// src/services/api/grc/AuthApi.js
import { BaseApiService } from '../BaseApiService';
import { validateRequired, validateEmail, post, get } from '../../utils/apiHelpers';

class AuthApi extends BaseApiService {
  constructor() {
    super('/auth', 'auth');
  }

  // Login user
  async login({ email, password }) {
    validateRequired({ email, password }, ['email', 'password']);
    validateEmail(email);

    try {
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      const endpoint = '/auth/login';
      const result = await post(endpoint, { email, password });
      
      // Store user info and token in localStorage
      localStorage.setItem('user', JSON.stringify(result.user));
      localStorage.setItem('token', result.token);
      
      return result;
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  }

  // Logout user
  async logout() {
    try {
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      const endpoint = '/auth/logout';
      const result = await post(endpoint, {});
      
      // Clear user info and token from localStorage
      localStorage.removeItem('user');
      localStorage.removeItem('token');
      
      return result;
    } catch (error) {
      console.error('Logout error:', error);
      throw error;
    }
  }

  // Get current user
  async getCurrentUser() {
    try {
      // Don't include this.baseUrl since apiHelpers.fetchWithAuth already adds API_BASE_URL
      const endpoint = '/auth/me';
      return await get(endpoint);
    } catch (error) {
      console.error('Get current user error:', error);
      throw error;
    }
  }

  // Check if user is authenticated
  isAuthenticated() {
    const token = localStorage.getItem('token');
    const user = localStorage.getItem('user');
    return !!token && !!user;
  }

  // Get current user from localStorage
  getCurrentUserFromStorage() {
    const userJson = localStorage.getItem('user');
    if (!userJson) return null;
    
    try {
      return JSON.parse(userJson);
    } catch (error) {
      console.error('Error parsing user from localStorage:', error);
      return null;
    }
  }

  // Get token from localStorage
  getToken() {
    return localStorage.getItem('token');
  }

  // Check if user has specific permission
  hasPermission(permission) {
    const user = this.getCurrentUserFromStorage();
    if (!user) return false;
    
    // Senior AOs have all permissions
    if (user.role === 'SENIOR_AO') return true;
    
    // For other roles, we would need to check the role permissions
    // This would typically involve a server call, but for simplicity
    // we'll just return true for now
    return true;
  }
}

export default new AuthApi();

================
File: grc/GrcUserApi.js
================
/* eslint-disable no-unused-vars */
// src/services/api/grc/GrcUserApi.js
import { BaseApiService } from '../BaseApiService';
import { validateRequired, validateEmail, get, post, put } from '../../utils/apiHelpers';
import { IS_MOCK } from '../../config';

class GrcUserApi extends BaseApiService {
  constructor() {
    super('/users', 'users');
  }

  // Get all GRC users
  async getGrcUsers() {
    try {
      const users = await this.getAll();
      return users.map(user => {
        // eslint-disable-next-line no-unused-vars
        const { password: _password, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
    } catch (error) {
      console.error('Error fetching GRC users:', error);
      throw error;
    }
  }

  // Create new GRC user
  async createGrcUser(userData) {
    validateRequired(userData, ['email', 'password', 'firstName', 'lastName', 'role']);
    validateEmail(userData.email);

    try {
      // Validate role exists
      const roles = await this.getRolesData();
      if (!roles[userData.role]) {
        throw new Error('Invalid role specified');
      }

      // Check for existing email
      const existingUsers = await this.getAll({ email: userData.email });
      if (existingUsers.length > 0) {
        throw new Error('Email already exists');
      }

      // Create new user
      const newUser = await this.create({
        ...userData,
        isActive: true,
        lastActive: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        failedLoginAttempts: 0,
        lastPasswordChange: new Date().toISOString(),
        preferences: {
          notifications: true,
          theme: 'light',
          language: 'en'
        }
      });

      // eslint-disable-next-line no-unused-vars
      const { password: _password, ...userWithoutPassword } = newUser;
      return userWithoutPassword;
    } catch (error) {
      console.error('Error creating GRC user:', error);
      throw error;
    }
  }

  // Update GRC user
  async updateGrcUser(id, updates) {
    try {
      // Check if user exists
      await this.getById(id);

      if (updates.email) {
        validateEmail(updates.email);
        // Check if email is taken by another user
        const existingUsers = await this.getAll({ email: updates.email });
        const otherUserWithEmail = existingUsers.find(user => String(user.id) !== String(id));
        if (otherUserWithEmail) {
          throw new Error('Email already exists');
        }
      }

      if (updates.role) {
        const roles = await this.getRolesData();
        if (!roles[updates.role]) {
          throw new Error('Invalid role specified');
        }
      }

      const updatedUser = await this.partialUpdate(id, {
        ...updates,
        updatedAt: new Date().toISOString()
      });

      // eslint-disable-next-line no-unused-vars
      const { password: _password, ...userWithoutPassword } = updatedUser;
      return userWithoutPassword;
    } catch (error) {
      console.error('Error updating GRC user:', error);
      throw error;
    }
  }

  // Get available GRC roles
  async getGrcRoles() {
    try {
      const roles = await this.getRolesData();
      return Object.keys(roles);
    } catch (error) {
      console.error('Error fetching GRC roles:', error);
      throw error;
    }
  }

  // Get GRC user by ID
  async getGrcUser(id) {
    try {
      const user = await this.getById(id);
      // eslint-disable-next-line no-unused-vars
      const { password: _password, ...userWithoutPassword } = user;
      return userWithoutPassword;
    } catch (error) {
      console.error('Error fetching GRC user:', error);
      throw error;
    }
  }

  // Check if GRC user has specific permission
  async hasPermission(userId, permission) {
    try {
      // Get user
      const user = await this.getById(userId);

      // Get role permissions
      const roles = await this.getRolesData();
      const userRole = roles[user.role];

      if (!userRole) return false;

      // Senior AOs have all permissions
      if (user.role === 'SENIOR_AO') return true;

      return userRole.permissions.includes(permission) || userRole.permissions.includes('all');
    } catch (error) {
      console.error('Error checking permission:', error);
      return false;
    }
  }

  // Helper method to get roles data
  async getRolesData() {
    if (IS_MOCK) {
      return {
        SENIOR_AO: {
          name: 'Senior Authorizing Official',
          permissions: ['all']
        },
        SUBORDINATE_AO: {
          name: 'Subordinate Authorizing Official',
          permissions: ['view', 'edit', 'approve']
        },
        AODR: {
          name: 'Authorizing Official Designated Representative',
          permissions: ['view', 'edit', 'review']
        },
        SCA: {
          name: 'Security Control Assessor',
          permissions: ['view', 'assess', 'review']
        },
        SCAR: {
          name: 'Security Control Assessor Representative',
          permissions: ['view', 'assess']
        }
      };
    }
    
    const response = await get(`${this.baseUrl}/roles`);
    return response;
  }
}

export default new GrcUserApi();

================
File: grc/settingsApi.js
================
import { delay, ApiError } from '../../api/BaseApiService';

// In-memory storage for settings
let systemSettings = {
  s3: {
    enabled: false,
    region: '',
    accessKeyId: '',
    secretAccessKey: '',
    defaultBucket: '',
    buckets: []
  }
};

const settingsApi = {
  // Get all system settings
  getSettings: async () => {
    await delay(300);
    return { ...systemSettings };
  },

  // Update S3 configuration
  updateS3Config: async (config) => {
    await delay(500);
    
    // Validate required fields
    const requiredFields = ['region', 'accessKeyId', 'secretAccessKey'];
    for (const field of requiredFields) {
      if (!config[field]) {
        throw new ApiError(`${field} is required`, 400);
      }
    }

    // In a real implementation, we would validate the credentials here
    // For now, we'll simulate a connection test
    await delay(1000); // Simulate AWS SDK validation

    systemSettings.s3 = {
      ...systemSettings.s3,
      ...config,
      enabled: true
    };

    return { 
      success: true, 
      message: 'S3 configuration updated successfully',
      config: { ...systemSettings.s3 }
    };
  },

  // Test S3 connection
  testS3Connection: async () => {
    await delay(800);
    
    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    // In a real implementation, we would test the connection here
    // For now, we'll simulate a successful connection
    return {
      success: true,
      message: 'Successfully connected to S3'
    };
  },

  // List S3 buckets
  listS3Buckets: async () => {
    await delay(500);

    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    // In a real implementation, we would fetch buckets from AWS
    // For now, return mock buckets
    return [
      { name: 'grc-documents', region: systemSettings.s3.region, createdAt: '2024-01-01T00:00:00Z' },
      { name: 'grc-backups', region: systemSettings.s3.region, createdAt: '2024-01-01T00:00:00Z' }
    ];
  },

  // Create new S3 bucket
  createS3Bucket: async (bucketName) => {
    await delay(800);

    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    if (!bucketName) {
      throw new ApiError('Bucket name is required', 400);
    }

    // Validate bucket name (simplified AWS S3 bucket naming rules)
    const bucketNameRegex = /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/;
    if (!bucketNameRegex.test(bucketName)) {
      throw new ApiError('Invalid bucket name. Must be 3-63 characters, lowercase, numbers, hyphens', 400);
    }

    // In a real implementation, we would create the bucket in AWS
    const newBucket = {
      name: bucketName,
      region: systemSettings.s3.region,
      createdAt: new Date().toISOString()
    };

    systemSettings.s3.buckets.push(newBucket);

    return {
      success: true,
      message: 'Bucket created successfully',
      bucket: { ...newBucket }
    };
  },

  // Set default S3 bucket
  setDefaultBucket: async (bucketName) => {
    await delay(300);

    if (!systemSettings.s3.enabled) {
      throw new ApiError('S3 is not configured', 400);
    }

    if (!bucketName) {
      throw new ApiError('Bucket name is required', 400);
    }

    // In a real implementation, we would verify the bucket exists in AWS
    systemSettings.s3.defaultBucket = bucketName;

    return {
      success: true,
      message: 'Default bucket updated successfully',
      defaultBucket: bucketName
    };
  }
};

export default settingsApi;

================
File: system/ArtifactsApi.js
================
import { validateRequired, ApiError } from '../../utils/apiHelpers';

const API_URL = 'http://localhost:3001';

export const artifactsApi = {
  // Get all artifacts
  getAllArtifacts: async () => {
    const response = await fetch(`${API_URL}/artifacts`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch artifacts', response.status);
    }
    return await response.json();
  },

  // Get artifact by ID
  getArtifactById: async (id) => {
    const response = await fetch(`${API_URL}/artifacts/${id}`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch artifact', response.status);
    }
    return await response.json();
  },

  // Create new artifact
  createArtifact: async (artifactData) => {
    validateRequired(artifactData, ['name', 'type']);
    
    const response = await fetch(`${API_URL}/artifacts`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        ...artifactData,
        uploadDate: new Date().toISOString()
      }),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to create artifact', response.status);
    }
    
    return await response.json();
  },

  // Update artifact
  updateArtifact: async (id, updateData) => {
    const response = await fetch(`${API_URL}/artifacts/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updateData),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update artifact', response.status);
    }
    
    return await response.json();
  },

  // Delete artifact
  deleteArtifact: async (id) => {
    const response = await fetch(`${API_URL}/artifacts/${id}`, {
      method: 'DELETE',
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to delete artifact', response.status);
    }
    
    return await response.json();
  },

  // Get artifact types
  getArtifactTypes: async () => {
    const response = await fetch(`${API_URL}/artifactTypes`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch artifact types', response.status);
    }
    const data = await response.json();
    return data.artifactTypes.map(type => type.name);
  },

  // Upload artifact file (mock implementation)
  uploadArtifactFile: async (file) => {
    // Simulate file upload and return a mock URL
    await new Promise(resolve => setTimeout(resolve, 1000));
    return {
      fileUrl: `/artifacts/${file.name}`,
      fileType: file.type,
      size: file.size
    };
  }
};

export default artifactsApi;

================
File: system/AssessmentApi.js
================
const API_URL = 'http://localhost:3001';

const handleError = (error) => {
  console.error('API Error:', error);
  throw error;
};

const assessmentApi = {
  // Assessment Plan APIs
  getAssessmentPlan: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentPlans?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch assessment plan');
      const plans = await response.json();
      return plans[0]; // Return the first matching plan
    } catch (error) {
      return handleError(error);
    }
  },

  updateAssessmentPlan: async (clientId, systemId, planData) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentPlans/${planData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...planData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update assessment plan');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Security Testing APIs
  getScanResults: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/scanResults?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch scan results');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  uploadScanResults: async (clientId, systemId, formData) => {
    try {
      const newScan = {
        id: `scan-${Date.now()}`,
        type: formData.get('type') || 'STIG Scan',
        date: new Date().toISOString(),
        findings: {
          high: parseInt(formData.get('highFindings') || '0'),
          medium: parseInt(formData.get('mediumFindings') || '0'),
          low: parseInt(formData.get('lowFindings') || '0')
        },
        status: 'Completed',
        downloadUrl: '#',
        detailsUrl: '#',
        clientId,
        systemId,
        assessmentPlanId: formData.get('assessmentPlanId'),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      const response = await fetch(
        `${API_URL}/scanResults`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(newScan)
        }
      );
      if (!response.ok) throw new Error('Failed to upload scan results');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  deleteScanResult: async (clientId, systemId, scanId) => {
    try {
      const response = await fetch(
        `${API_URL}/scanResults/${scanId}`,
        {
          method: 'DELETE'
        }
      );
      if (!response.ok) throw new Error('Failed to delete scan result');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Control Assessment APIs
  getControlAssessments: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/controls?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch control assessments');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  updateControlAssessment: async (clientId, systemId, controlData) => {
    try {
      const response = await fetch(
        `${API_URL}/controls/${controlData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...controlData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update control assessment');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  // Documentation Review APIs
  getDocumentationReview: async (clientId, systemId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments?clientId=${clientId}&systemId=${systemId}`
      );
      if (!response.ok) throw new Error('Failed to fetch documentation review');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  updateDocumentReview: async (clientId, systemId, documentData) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments/${documentData.id}`,
        {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...documentData,
            updatedAt: new Date().toISOString()
          }),
        }
      );
      if (!response.ok) throw new Error('Failed to update document review');
      return response.json();
    } catch (error) {
      return handleError(error);
    }
  },

  getDocumentDownloadUrl: async (clientId, systemId, documentId) => {
    try {
      const response = await fetch(
        `${API_URL}/assessmentDocuments/${documentId}`
      );
      if (!response.ok) throw new Error('Failed to get document download URL');
      const doc = await response.json();
      return doc.downloadUrl || '#';
    } catch (error) {
      return handleError(error);
    }
  },
};

export default assessmentApi;

================
File: system/AtoTrackerApi.js
================
/* eslint-disable no-unused-vars */
import { ApiError } from '../../api/BaseApiService';

const API_URL = 'http://localhost:3001';

const atoTrackerApi = {
  // Get ATO process data for a system
  getATOProcess: async (clientId, systemId) => {
    // Get the process steps template
    const processStepsResponse = await fetch(`${API_URL}/ato/process-steps`);
    if (!processStepsResponse.ok) {
      throw new ApiError('Failed to fetch process steps', processStepsResponse.status);
    }
    const processSteps = await processStepsResponse.json();
    
    try {
      // Try to get existing tracker data for the system
      const trackerResponse = await fetch(`${API_URL}/ato/tracker/${systemId}`);
      if (!trackerResponse.ok) {
        throw new ApiError('Tracker data not found', trackerResponse.status);
      }
      return await trackerResponse.json();
    } catch (error) {
      // If no tracker data exists, initialize it from process steps
      const initialData = {
        phases: processSteps.processSteps.map(phase => ({
          ...phase,
          progress: 0,
          sections: phase.sections.map(section => ({
            ...section,
            tasks: section.tasks.map(task => ({
              description: task,
              completed: false
            }))
          }))
        }))
      };

      // Create new tracker data for the system
      const createResponse = await fetch(`${API_URL}/ato/tracker/${systemId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(initialData),
      });
      
      if (!createResponse.ok) {
        throw new ApiError('Failed to create tracker data', createResponse.status);
      }
      
      return await createResponse.json();
    }
  },

  // Update task status
  updateTaskStatus: async (clientId, systemId, phaseId, sectionTitle, taskIndex, completed) => {
    // Get current tracker data
    const trackerResponse = await fetch(`${API_URL}/ato/tracker/${systemId}`);
    if (!trackerResponse.ok) {
      throw new ApiError('Failed to fetch tracker data', trackerResponse.status);
    }
    const trackerData = await trackerResponse.json();
    
    // Find and update the task
    const phase = trackerData.phases.find(p => p.id === phaseId);
    if (phase) {
      const section = phase.sections.find(s => s.title === sectionTitle);
      if (section && section.tasks[taskIndex]) {
        section.tasks[taskIndex].completed = completed;
        
        // Calculate and update phase progress
        const totalTasks = phase.sections.reduce((sum, s) => sum + s.tasks.length, 0);
        const completedTasks = phase.sections.reduce((sum, s) => 
          sum + s.tasks.filter(t => t.completed).length, 0);
        phase.progress = Math.round((completedTasks / totalTasks) * 100);
      }
    }

    // Update the tracker data
    const updateResponse = await fetch(`${API_URL}/ato/tracker/${systemId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(trackerData),
    });
    
    if (!updateResponse.ok) {
      throw new ApiError('Failed to update tracker data', updateResponse.status);
    }
    
    return await updateResponse.json();
  },

  // Get phase progress
  getPhaseProgress: async (clientId, systemId, phaseId) => {
    const trackerResponse = await fetch(`${API_URL}/ato/tracker/${systemId}`);
    if (!trackerResponse.ok) {
      throw new ApiError('Failed to fetch tracker data', trackerResponse.status);
    }
    const trackerData = await trackerResponse.json();
    const phase = trackerData.phases.find(p => p.id === phaseId);
    return {
      value: phase ? phase.progress : 0
    };
  },

  // Reset process data (useful for testing)
  resetProcessData: async () => {
    // Get the process steps template
    const processStepsResponse = await fetch(`${API_URL}/ato/process-steps`);
    if (!processStepsResponse.ok) {
      throw new ApiError('Failed to fetch process steps', processStepsResponse.status);
    }
    const processSteps = await processStepsResponse.json();
    
    // Initialize empty tracker data
    const initialData = {
      phases: processSteps.processSteps.map(phase => ({
        ...phase,
        progress: 0,
        sections: phase.sections.map(section => ({
          ...section,
          tasks: section.tasks.map(task => ({
            description: task,
            completed: false
          }))
        }))
      }))
    };

    // Reset tracker data for the system
    const resetResponse = await fetch(`${API_URL}/ato/tracker/sys-001`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(initialData),
    });
    
    if (!resetResponse.ok) {
      throw new ApiError('Failed to reset tracker data', resetResponse.status);
    }
    
    return await resetResponse.json();
  }
};

export default atoTrackerApi;

================
File: system/AuthorizationApi.js
================
import { ApiError } from '../../api/BaseApiService';

const API_URL = 'http://localhost:3001';

const authorizationApi = {
  // Get authorization data for a system
  getAuthorizationData: async (clientId, systemId) => {
    const response = await fetch(`${API_URL}/authorization/${clientId}/${systemId}`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch authorization data', response.status);
    }
    return await response.json();
  },

  // Update risk assessment
  updateRiskAssessment: async (clientId, systemId, riskData) => {
    const response = await fetch(`${API_URL}/authorization/${clientId}/${systemId}/risk-assessment`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(riskData),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update risk assessment', response.status);
    }
    
    return await response.json();
  },

  // Create POA&M item
  createPOAMItem: async (clientId, systemId, poamItem) => {
    const response = await fetch(`${API_URL}/authorization/${clientId}/${systemId}/poam`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(poamItem),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to create POA&M item', response.status);
    }
    
    return await response.json();
  },

  // Update authorization package
  updateAuthorizationPackage: async (clientId, systemId, packageData) => {
    const response = await fetch(`${API_URL}/authorization/${clientId}/${systemId}/package`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(packageData),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update authorization package', response.status);
    }
    
    return await response.json();
  },

  // Validate authorization package
  validateAuthorizationPackage: async (clientId, systemId) => {
    const response = await fetch(`${API_URL}/authorization/${clientId}/${systemId}/validate`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to validate authorization package', response.status);
    }
    
    return await response.json();
  },

  // Update authorization decision
  updateAuthorizationDecision: async (clientId, systemId, decisionData) => {
    const response = await fetch(`${API_URL}/authorization/${clientId}/${systemId}/decision`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(decisionData),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update authorization decision', response.status);
    }
    
    return await response.json();
  }
};

export default authorizationApi;

================
File: system/InitialAssessmentApi.js
================
import { validateRequired, checkExists } from '../../utils/apiHelpers';

const API_URL = 'http://localhost:3001';

const initialAssessmentApi = {
  // Get initial assessment data
  getInitialAssessment: async (clientId, systemId) => {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const response = await fetch(`${API_URL}/systems/${systemId}?clientId=${clientId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch system data');
    }
    
    const system = await response.json();
    checkExists(system, 'System');
    
    return { 
      ...system.phases.initialAssessment,
      lastUpdated: system.updatedAt
    };
  },

  // Update system discovery
  updateSystemDiscovery: async (clientId, systemId, discoveryData) => {
    validateRequired({ 
      clientId, 
      systemId,
      ...discoveryData
    }, [
      'clientId',
      'systemId',
      'description',
      'purpose',
      'informationLevel',
    ]);

    const response = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'GET'
    });
    if (!response.ok) {
      throw new Error('Failed to fetch system data');
    }
    
    const system = await response.json();
    checkExists(system, 'System');

    const updatedSystem = {
      ...system,
      phases: {
        ...system.phases,
        initialAssessment: {
          ...system.phases.initialAssessment,
          discovery: {
            ...discoveryData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    const updateResponse = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedSystem)
    });

    if (!updateResponse.ok) {
      throw new Error('Failed to update system discovery');
    }

    const result = await updateResponse.json();
    return {
      success: true,
      data: result.phases.initialAssessment.discovery
    };
  },

  // Update environment analysis
  updateEnvironmentAnalysis: async (clientId, systemId, environmentData) => {
    validateRequired({ 
      clientId, 
      systemId,
      ...environmentData
    }, [
      'clientId',
      'systemId',
      'hosting',
      'components',
      'networkArchitecture',
      'dependencies',
      'interfaces'
    ]);

    const response = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'GET'
    });
    if (!response.ok) {
      throw new Error('Failed to fetch system data');
    }
    
    const system = await response.json();
    checkExists(system, 'System');

    const updatedSystem = {
      ...system,
      phases: {
        ...system.phases,
        initialAssessment: {
          ...system.phases.initialAssessment,
          environment: {
            ...environmentData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    const updateResponse = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedSystem)
    });

    if (!updateResponse.ok) {
      throw new Error('Failed to update environment analysis');
    }

    const result = await updateResponse.json();
    return {
      success: true,
      data: result.phases.initialAssessment.environment
    };
  },

  // Update network boundary
  updateNetworkBoundary: async (clientId, systemId, boundaryData) => {
    validateRequired({ 
      clientId, 
      systemId,
      ...boundaryData
    }, [
      'clientId',
      'systemId',
      'description',
      'ports',
      'protocols',
      'procedures'
    ]);

    const response = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'GET'
    });
    if (!response.ok) {
      throw new Error('Failed to fetch system data');
    }
    
    const system = await response.json();
    checkExists(system, 'System');

    const updatedSystem = {
      ...system,
      phases: {
        ...system.phases,
        initialAssessment: {
          ...system.phases.initialAssessment,
          boundary: {
            ...boundaryData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    const updateResponse = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedSystem)
    });

    if (!updateResponse.ok) {
      throw new Error('Failed to update network boundary');
    }

    const result = await updateResponse.json();
    return {
      success: true,
      data: result.phases.initialAssessment.boundary
    };
  },

  // Update stakeholders
  updateStakeholders: async (clientId, systemId, stakeholderData) => {
    validateRequired({ 
      clientId, 
      systemId,
      ...stakeholderData
    }, [
      'clientId',
      'systemId',
      'owners',
      'operators',
      'responsibilities',
      'contacts',
      'communicationChannels'
    ]);

    const response = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'GET'
    });
    if (!response.ok) {
      throw new Error('Failed to fetch system data');
    }
    
    const system = await response.json();
    checkExists(system, 'System');

    const updatedSystem = {
      ...system,
      phases: {
        ...system.phases,
        initialAssessment: {
          ...system.phases.initialAssessment,
          stakeholders: {
            ...stakeholderData,
            status: 'completed',
            updatedAt: new Date().toISOString()
          }
        }
      }
    };

    const updateResponse = await fetch(`${API_URL}/systems/${systemId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedSystem)
    });

    if (!updateResponse.ok) {
      throw new Error('Failed to update stakeholders');
    }

    const result = await updateResponse.json();
    return {
      success: true,
      data: result.phases.initialAssessment.stakeholders
    };
  },

  // Get initial assessment progress
  getProgress: async (clientId, systemId) => {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    const response = await fetch(`${API_URL}/systems/${systemId}?clientId=${clientId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch system data');
    }
    
    const system = await response.json();
    checkExists(system, 'System');

    const sections = [
      system.phases.initialAssessment?.discovery?.status,
      system.phases.initialAssessment?.environment?.status,
      system.phases.initialAssessment?.boundary?.status,
      system.phases.initialAssessment?.stakeholders?.status
    ];

    const completedSections = sections.filter(status => status === 'completed').length;
    const progress = Math.round((completedSections / sections.length) * 100);

    return {
      progress,
      sections: {
        discovery: system.phases.initialAssessment?.discovery?.status || 'not_started',
        environment: system.phases.initialAssessment?.environment?.status || 'not_started',
        boundary: system.phases.initialAssessment?.boundary?.status || 'not_started',
        stakeholders: system.phases.initialAssessment?.stakeholders?.status || 'not_started'
      }
    };
  }
};

export default initialAssessmentApi;

================
File: system/SystemApi.js
================
/* eslint-disable no-unused-vars */
// src/services/api/system/SystemApi.js
import { BaseApiService } from '../BaseApiService';
import { validateRequired, get, post, put } from '../../utils/apiHelpers';
import { IS_MOCK } from '../../config';

// Re-export enums for backward compatibility
export const SystemStatus = {
  DRAFT: 'DRAFT',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export const ATOStatus = {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  APPROVED: 'APPROVED',
  DENIED: 'DENIED',
  EXPIRED: 'EXPIRED'
};

export const SecurityLevel = {
  LOW: 'low',
  MODERATE: 'moderate',
  HIGH: 'high'
};

export const InformationLevel = {
  PUBLIC: 'public',
  INTERNAL: 'internal',
  CONFIDENTIAL: 'confidential',
  RESTRICTED: 'restricted'
};

export const SystemCategory = {
  MISSION_CRITICAL: 'Mission Critical',
  BUSINESS_CRITICAL: 'Business Critical',
  BUSINESS_OPERATIONAL: 'Business Operational',
  BUSINESS_SUPPORT: 'Business Support'
};

class SystemApi extends BaseApiService {
  constructor() {
    super('/systems', 'systems');
  }

  // Get all systems for a client
  async getSystems(clientId) {
    validateRequired({ clientId }, ['clientId']);
    return this.getAll({ clientId: Number(clientId) });
  }

  // Get a single system
  async getSystem(clientId, systemId) {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    try {
      // Get base system data
      const system = await this.getById(systemId);
      
      // Get authorization data
      const authResponse = await get(`${this.baseUrl}/authorization/${clientId}/${systemId}`);
      
      // Combine system and authorization data
      return {
        ...system,
        phases: {
          ...system.phases,
          authorization: authResponse
        }
      };
    } catch (error) {
      console.error('Error fetching system:', error);
      throw error;
    }
  }

  // Create a new system
  async createSystem(clientId, systemData) {
    validateRequired({ clientId }, ['clientId']);
    validateRequired(systemData, ['name', 'type', 'securityLevel', 'informationLevel', 'category']);
    
    // Prepare the system data with client ID
    const newSystemData = {
      ...systemData,
      clientId: Number(clientId),
      status: 'IN_PROGRESS',
      atoStatus: 'NOT_STARTED',
      currentPhase: 'initial_assessment',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      lastAssessment: null,
      phaseProgress: {
        'initial-assessment': 0,
        'system-categorization': 0,
        'security-controls': 0,
        'assessment': 0,
        'ato-authorization': 0,
        'continuous-monitoring': 0
      },
      phases: {
        initialAssessment: {
          discovery: {
            status: 'not_started',
            completedItems: [],
            pendingItems: []
          },
          gapAnalysis: {
            status: 'not_started',
            completedItems: [],
            pendingItems: []
          },
          environment: {
            status: 'not_started',
            details: {
              hosting: '',
              components: []
            }
          },
          stakeholders: {
            status: 'not_started',
            identified: [],
            pending: []
          }
        },
        systemCategorization: {
          infoTypes: {
            status: 'not_started',
            identified: [],
            pending: []
          },
          impact: {
            status: 'not_started',
            assessments: {
              confidentiality: null,
              integrity: null,
              availability: null
            }
          },
          objectives: {
            status: 'not_started',
            defined: [],
            pending: []
          }
        },
        securityControls: {
          baseline: {
            status: 'not_started',
            selected: null,
            rationale: null
          },
          tailoring: {
            status: 'not_started',
            completedControls: [],
            pendingControls: []
          },
          implementation: {
            status: 'not_started',
            implemented: [],
            pending: []
          },
          documentation: {
            status: 'not_started',
            completed: [],
            pending: []
          }
        },
        assessment: {
          planning: {
            status: 'not_started',
            completed: [],
            pending: []
          },
          testing: {
            status: 'not_started',
            completed: [],
            pending: []
          },
          review: {
            status: 'not_started',
            completed: [],
            pending: []
          }
        },
        authorization: {
          riskAssessment: {
            status: 'not_started',
            completed: [],
            pending: []
          },
          package: {
            status: 'not_started',
            completed: [],
            pending: []
          },
          decision: {
            status: 'not_started',
            result: null,
            conditions: []
          }
        },
        continuousMonitoring: {
          program: {
            status: 'not_started',
            defined: [],
            pending: []
          },
          assessment: {
            status: 'not_started',
            completed: [],
            pending: []
          },
          maintenance: {
            status: 'not_started',
            completed: [],
            pending: []
          }
        }
      },
      components: [],
      networks: [],
      ports: [],
      procedures: [],
      artifacts: [],
      boundaries: {
        physical: [],
        network: [],
        security: []
      },
      compliance: {
        nist: 0,
        hipaa: 0,
        pci: 0
      }
    };
    
    return this.create(newSystemData);
  }

  // Update an existing system
  async updateSystem(clientId, systemId, systemData) {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    validateRequired(systemData, ['name', 'type', 'securityLevel', 'informationLevel', 'category']);
    
    // Prepare the update data
    const updateData = {
      ...systemData,
      clientId: Number(clientId),
      updatedAt: new Date().toISOString()
    };
    
    return this.update(systemId, updateData);
  }

  // Delete a system
  async deleteSystem(clientId, systemId) {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    return this.delete(systemId);
  }

  // Create a new POAM item
  async createPOAMItem(clientId, systemId, poamData) {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    validateRequired(poamData, ['title', 'description', 'severity']);
    
    return post(`${this.baseUrl}/authorization/${clientId}/${systemId}/poam`, {
      ...poamData,
      status: 'OPEN',
      dateCreated: new Date().toISOString().split('T')[0]
    });
  }

  // Update authorization package
  async updateAuthorizationPackage(clientId, systemId, packageData) {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    return put(`${this.baseUrl}/authorization/${clientId}/${systemId}/package`, packageData);
  }

  // Update authorization decision
  async updateAuthorizationDecision(clientId, systemId, decisionData) {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    return put(`${this.baseUrl}/authorization/${clientId}/${systemId}/decision`, decisionData);
  }

  // Validate authorization package
  async validateAuthorizationPackage(clientId, systemId) {
    validateRequired({ clientId, systemId }, ['clientId', 'systemId']);
    
    if (IS_MOCK) {
      // Return mock validation results
      return {
        status: 'VALIDATED',
        timestamp: new Date().toISOString().split('T')[0],
        findings: [],
        recommendations: [
          'Ensure all POA&M items have detailed remediation plans',
          'Update system boundary documentation with network diagrams',
          'Include detailed testing results in security assessment report'
        ]
      };
    }
    
    return put(`${this.baseUrl}/authorization/${clientId}/${systemId}/validate`, {});
  }

  // Get system types
  async getSystemTypes() {
    if (IS_MOCK) {
      return ['Cloud', 'On-Premise', 'Hybrid', 'SaaS', 'PaaS', 'IaaS'];
    }
    const data = await get(`${this.baseUrl}/system-types`);
    return data.map(type => type.name);
  }

  // Get network types
  async getNetworkTypes() {
    if (IS_MOCK) {
      return ['LAN', 'WAN', 'VPN', 'Internet', 'Intranet', 'Extranet'];
    }
    const data = await get(`${this.baseUrl}/network-types`);
    return data.map(type => type.name);
  }

  // Get component types
  async getComponentTypes() {
    if (IS_MOCK) {
      return ['Server', 'Database', 'Application', 'Network Device', 'Security Device', 'Endpoint'];
    }
    const data = await get(`${this.baseUrl}/component-types`);
    return data.map(type => type.name);
  }

  // Get procedure types
  async getProcedureTypes() {
    if (IS_MOCK) {
      return ['Backup', 'Recovery', 'Incident Response', 'Change Management', 'Access Control'];
    }
    const data = await get(`${this.baseUrl}/procedure-types`);
    return data.map(type => type.name);
  }

  // Get common ports
  async getCommonPorts() {
    if (IS_MOCK) {
      return [
        { port: 80, service: 'HTTP' },
        { port: 443, service: 'HTTPS' },
        { port: 22, service: 'SSH' },
        { port: 21, service: 'FTP' },
        { port: 25, service: 'SMTP' },
        { port: 3306, service: 'MySQL' }
      ];
    }
    return get(`${this.baseUrl}/common-ports`);
  }

  // Get system statuses
  async getSystemStatuses() {
    if (IS_MOCK) {
      return Object.values(SystemStatus);
    }
    const data = await get(`${this.baseUrl}/system-statuses`);
    return data.map(status => status.name);
  }

  // Get ATO statuses
  async getATOStatuses() {
    if (IS_MOCK) {
      return Object.values(ATOStatus);
    }
    const data = await get(`${this.baseUrl}/ato-statuses`);
    return data.map(status => status.name);
  }

  // Get security levels
  async getSecurityLevels() {
    if (IS_MOCK) {
      return Object.values(SecurityLevel);
    }
    const data = await get(`${this.baseUrl}/security-levels`);
    return data.map(level => level.name);
  }

  // Get information levels
  async getInformationLevels() {
    if (IS_MOCK) {
      return Object.values(InformationLevel);
    }
    const data = await get(`${this.baseUrl}/information-levels`);
    return data.map(level => level.name);
  }

  // Get system categories
  async getSystemCategories() {
    if (IS_MOCK) {
      return Object.values(SystemCategory);
    }
    const data = await get(`${this.baseUrl}/system-categories`);
    return data.map(category => category.name);
  }
}

export default new SystemApi();

================
File: system/SystemCategorizationApi.js
================
import { ApiError } from '../../api/BaseApiService';


const API_URL = 'http://localhost:3001';

export const systemCategorizationApi = {
  // Information Types
  getInformationTypes: async (clientId, systemId) => {
    const response = await fetch(`${API_URL}/categorization/${systemId}/information-types`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch information types', response.status);
    }
    const data = await response.json();
    return data.informationTypes;
  },

  updateInformationTypes: async (clientId, systemId, data) => {
    const response = await fetch(`${API_URL}/categorization/${systemId}/information-types`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update information types', response.status);
    }
    
    const responseData = await response.json();
    return responseData.informationTypes;
  },

  // Impact Analysis
  getImpactAnalysis: async (clientId, systemId) => {
    const response = await fetch(`${API_URL}/categorization/${systemId}/impact-analysis`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch impact analysis', response.status);
    }
    const data = await response.json();
    return data.impactAnalysis;
  },

  updateImpactAnalysis: async (clientId, systemId, data) => {
    const response = await fetch(`${API_URL}/categorization/${systemId}/impact-analysis`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update impact analysis', response.status);
    }
    
    const responseData = await response.json();
    return responseData.impactAnalysis;
  },

  // Security Objectives
  getSecurityObjectives: async (clientId, systemId) => {
    const response = await fetch(`${API_URL}/categorization/${systemId}/security-objectives`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch security objectives', response.status);
    }
    const data = await response.json();
    return data.securityObjectives;
  },

  updateSecurityObjectives: async (clientId, systemId, data) => {
    const response = await fetch(`${API_URL}/categorization/${systemId}/security-objectives`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update security objectives', response.status);
    }
    
    const responseData = await response.json();
    return responseData.securityObjectives;
  },

  // Progress tracking
  getProgress: async (clientId, systemId) => {
    const response = await fetch(`${API_URL}/categorization/${systemId}/progress`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch progress', response.status);
    }
    const data = await response.json();
    return data.progress;
  }
};

export default systemCategorizationApi;

================
File: system/SystemComponentsApi.js
================
import { ApiError } from '../../api/BaseApiService';

const API_URL = 'http://localhost:3001';

export const systemComponentsApi = {
  // Get component types
  getComponentTypes: async () => {
    const response = await fetch(`${API_URL}/system-component-types`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch component types', response.status);
    }
    const data = await response.json();
    return data.componentTypes.map(type => type.name);
  },
  
  // Get component statuses
  getComponentStatuses: async () => {
    const response = await fetch(`${API_URL}/system-component-statuses`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch component statuses', response.status);
    }
    const data = await response.json();
    return data.componentStatuses.map(status => status.name);
  },

  // Get all components
  getComponents: async () => {
    const response = await fetch(`${API_URL}/system-components`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch components', response.status);
    }
    return await response.json();
  },

  // Get component by ID
  getComponent: async (id) => {
    const response = await fetch(`${API_URL}/system-components/${id}`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch component', response.status);
    }
    return await response.json();
  },

  // Create new component
  createComponent: async (componentData) => {
    const newComponent = {
      ...componentData,
      lastUpdated: new Date().toISOString(),
      status: componentData.status || 'ACTIVE'
    };
    
    const response = await fetch(`${API_URL}/system-components`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(newComponent),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to create component', response.status);
    }
    
    return await response.json();
  },

  // Update component
  updateComponent: async (id, updateData) => {
    const updatedComponent = {
      ...updateData,
      lastUpdated: new Date().toISOString()
    };

    const response = await fetch(`${API_URL}/system-components/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updatedComponent),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update component', response.status);
    }
    
    return await response.json();
  },

  // Delete component
  deleteComponent: async (id) => {
    const response = await fetch(`${API_URL}/system-components/${id}`, {
      method: 'DELETE',
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to delete component', response.status);
    }
    
    return { success: true, message: 'Component deleted successfully' };
  }
};

export default systemComponentsApi;

================
File: system/SystemControlsApi.js
================
import { validateRequired, ApiError } from '../../utils/apiHelpers';
//import { ApiError } from '../../api/BaseApiService';

const API_URL = 'http://localhost:3001';

export const systemControlsApi = {
  // Get controls with filtering options
  getControls: async (filters = {}) => {
    const queryParams = new URLSearchParams();
    if (filters.family) queryParams.append('family', filters.family);
    if (filters.impactLevel) queryParams.append('impactLevel', filters.impactLevel);

    let endpoint = '/security-controls';
    if (filters.type) {
      endpoint = `/security-controls/${filters.type.toLowerCase()}`;
    }

    const response = await fetch(`${API_URL}${endpoint}?${queryParams}`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch controls', response.status);
    }
    return await response.json();
  },

  // Create a new control
  createControl: async (controlData) => {
    validateRequired(controlData, ['name', 'family', 'description']);
    
    const response = await fetch(`${API_URL}/security-controls`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(controlData),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to create control', response.status);
    }
    
    return await response.json();
  },

  // Update a control
  updateControl: async (controlId, controlData) => {
    const response = await fetch(`${API_URL}/security-controls/${controlId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(controlData),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update control', response.status);
    }
    
    return await response.json();
  },

  // Update control implementation status
  updateControlStatus: async (controlId, status) => {
    const response = await fetch(`${API_URL}/security-controls/${controlId}/status`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ status }),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to update control status', response.status);
    }
    
    return await response.json();
  },

  // Get control families
  getControlFamilies: async () => {
    const response = await fetch(`${API_URL}/security-control-families`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch control families', response.status);
    }
    const data = await response.json();
    return data.families;
  },

  // Add evidence to a control
  addControlEvidence: async (controlId, evidence) => {
    // If evidence is a FormData object (file upload)
    if (evidence instanceof FormData) {
      const formData = new FormData();
      formData.append('evidence', evidence.get('evidence'));
      
      const response = await fetch(`${API_URL}/security-controls/${controlId}/evidence`, {
        method: 'POST',
        body: formData,
      });
      
      if (!response.ok) {
        throw new ApiError('Failed to add control evidence', response.status);
      }
      
      return await response.json();
    }
    
    // If evidence is JSON data
    const response = await fetch(`${API_URL}/security-controls/${controlId}/evidence`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(evidence),
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to add control evidence', response.status);
    }
    
    return await response.json();
  },

  // Delete evidence from a control
  deleteControlEvidence: async (controlId, evidenceId) => {
    const response = await fetch(`${API_URL}/security-controls/${controlId}/evidence/${evidenceId}`, {
      method: 'DELETE',
    });
    
    if (!response.ok) {
      throw new ApiError('Failed to delete control evidence', response.status);
    }
    
    return await response.json();
  },

  // Get control implementation statistics
  getControlStats: async () => {
    const response = await fetch(`${API_URL}/security-control-stats`);
    if (!response.ok) {
      throw new ApiError('Failed to fetch control stats', response.status);
    }
    return await response.json();
  }
};

export default systemControlsApi;



================================================================
End of Codebase
================================================================
